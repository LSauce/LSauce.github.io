<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.67" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://jf.kiroe.cn/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html"><meta property="og:site_name" content="JavaFarms"><meta property="og:title" content="06.面向对象设计"><meta property="og:description" content="学习目标: 掌握抽象类的定义; 掌握抽象类的特点与使用; 引例 以下猫狗继承案例，是一个非常基础的继承语法的代码。思考一下Animal类的继承体系，有什么问题吗？ 从以下两个角度分析： 1. 从代码角度上，有没有冗余代码？ 2. 从设计角度上，在这个案例中，会存在一个动物对象吗？ 分析一下 1. 单纯从代码角度上，有没有冗余代码？ 实际上是有的。从方法..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="JavaFarmer"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"06.面向对象设计","image":[""],"dateModified":null,"author":[{"@type":"Person","name":"JavaFarmer","url":"https://jf.kiroe.cn"}]}</script><title>06.面向对象设计 | JavaFarms</title><meta name="description" content="学习目标: 掌握抽象类的定义; 掌握抽象类的特点与使用; 引例 以下猫狗继承案例，是一个非常基础的继承语法的代码。思考一下Animal类的继承体系，有什么问题吗？ 从以下两个角度分析： 1. 从代码角度上，有没有冗余代码？ 2. 从设计角度上，在这个案例中，会存在一个动物对象吗？ 分析一下 1. 单纯从代码角度上，有没有冗余代码？ 实际上是有的。从方法...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-b8845d42.css" as="style"><link rel="stylesheet" href="/assets/style-b8845d42.css">
    <link rel="modulepreload" href="/assets/app-58d2c58f.js"><link rel="modulepreload" href="/assets/6_面向对象设计.html-180e4923.js"><link rel="modulepreload" href="/assets/6_面向对象设计.html-ecedbbaa.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js"><link rel="prefetch" href="/assets/index.html-8b0da2f8.js" as="script"><link rel="prefetch" href="/assets/slides.html-06c60ee3.js" as="script"><link rel="prefetch" href="/assets/111.二叉树的最小深度.html-c3759c57.js" as="script"><link rel="prefetch" href="/assets/index.html-12824d2e.js" as="script"><link rel="prefetch" href="/assets/index.html-bf2b997f.js" as="script"><link rel="prefetch" href="/assets/0_IDEA安装与设置.html-cc1b696c.js" as="script"><link rel="prefetch" href="/assets/0_Java基本介绍.html-bbfcbd83.js" as="script"><link rel="prefetch" href="/assets/0_git使用.html-b515bfa9.js" as="script"><link rel="prefetch" href="/assets/0_常用软件.html-c564764e.js" as="script"><link rel="prefetch" href="/assets/10_异常.html-452e35b9.js" as="script"><link rel="prefetch" href="/assets/11_File.html-062f419a.js" as="script"><link rel="prefetch" href="/assets/12_IO.html-2fb86795.js" as="script"><link rel="prefetch" href="/assets/14_网络编程.html-6e6c8f8a.js" as="script"><link rel="prefetch" href="/assets/15_反射.html-825dc706.js" as="script"><link rel="prefetch" href="/assets/16_注解.html-4ede9ad6.js" as="script"><link rel="prefetch" href="/assets/17_GC.html-4e507034.js" as="script"><link rel="prefetch" href="/assets/2_方法.html-65036dcd.js" as="script"><link rel="prefetch" href="/assets/3_补充递归.html-3fafbb08.js" as="script"><link rel="prefetch" href="/assets/4_面向对象基础.html-3d8c71d3.js" as="script"><link rel="prefetch" href="/assets/5_面向对象三大特征.html-c963b7db.js" as="script"><link rel="prefetch" href="/assets/8_补充其他常用类.html-a222f1c2.js" as="script"><link rel="prefetch" href="/assets/9_String.html-3f8b08a6.js" as="script"><link rel="prefetch" href="/assets/index.html-e90b828d.js" as="script"><link rel="prefetch" href="/assets/index.html-b5369b7a.js" as="script"><link rel="prefetch" href="/assets/baz.html-6a4a3825.js" as="script"><link rel="prefetch" href="/assets/index.html-5646379c.js" as="script"><link rel="prefetch" href="/assets/ray.html-75298494.js" as="script"><link rel="prefetch" href="/assets/git协同上传文章手册.html-75ac4af0.js" as="script"><link rel="prefetch" href="/assets/分支测试.html-86de3404.js" as="script"><link rel="prefetch" href="/assets/404.html-23d166f3.js" as="script"><link rel="prefetch" href="/assets/index.html-900244cb.js" as="script"><link rel="prefetch" href="/assets/index.html-2dc067e6.js" as="script"><link rel="prefetch" href="/assets/index.html-39efe404.js" as="script"><link rel="prefetch" href="/assets/slides.html-cb3e087c.js" as="script"><link rel="prefetch" href="/assets/111.二叉树的最小深度.html-2b994ddf.js" as="script"><link rel="prefetch" href="/assets/index.html-0d70e827.js" as="script"><link rel="prefetch" href="/assets/index.html-750c711d.js" as="script"><link rel="prefetch" href="/assets/0_IDEA安装与设置.html-43979e5e.js" as="script"><link rel="prefetch" href="/assets/0_Java基本介绍.html-765494f9.js" as="script"><link rel="prefetch" href="/assets/0_git使用.html-4ddfcabe.js" as="script"><link rel="prefetch" href="/assets/0_常用软件.html-895d00b8.js" as="script"><link rel="prefetch" href="/assets/10_异常.html-b79ac0bb.js" as="script"><link rel="prefetch" href="/assets/11_File.html-a3e1f2d7.js" as="script"><link rel="prefetch" href="/assets/12_IO.html-4fd719e6.js" as="script"><link rel="prefetch" href="/assets/14_网络编程.html-7d72c16f.js" as="script"><link rel="prefetch" href="/assets/15_反射.html-19832de1.js" as="script"><link rel="prefetch" href="/assets/16_注解.html-22ee790e.js" as="script"><link rel="prefetch" href="/assets/17_GC.html-7ac18219.js" as="script"><link rel="prefetch" href="/assets/2_方法.html-8d7f1dce.js" as="script"><link rel="prefetch" href="/assets/3_补充递归.html-2630c40b.js" as="script"><link rel="prefetch" href="/assets/4_面向对象基础.html-42d451f2.js" as="script"><link rel="prefetch" href="/assets/5_面向对象三大特征.html-3ac8dfef.js" as="script"><link rel="prefetch" href="/assets/8_补充其他常用类.html-90165cb2.js" as="script"><link rel="prefetch" href="/assets/9_String.html-f57dcd61.js" as="script"><link rel="prefetch" href="/assets/index.html-315ed14e.js" as="script"><link rel="prefetch" href="/assets/index.html-5fa301e3.js" as="script"><link rel="prefetch" href="/assets/baz.html-a09199b0.js" as="script"><link rel="prefetch" href="/assets/index.html-de2c4154.js" as="script"><link rel="prefetch" href="/assets/ray.html-5b804ad4.js" as="script"><link rel="prefetch" href="/assets/git协同上传文章手册.html-2d382f50.js" as="script"><link rel="prefetch" href="/assets/分支测试.html-df7f5b8e.js" as="script"><link rel="prefetch" href="/assets/404.html-c8dbd472.js" as="script"><link rel="prefetch" href="/assets/index.html-8f3aa0fc.js" as="script"><link rel="prefetch" href="/assets/index.html-e03f8b40.js" as="script"><link rel="prefetch" href="/assets/giscus-0b7adcf8.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-1464cdb9.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/"><img class="vp-nav-logo" src="/logo.svg" alt="JavaFarms"><!----><span class="vp-site-name hide-in-pad">JavaFarms</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="JavaFarms主页" class="vp-link nav-link nav-link" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>JavaFarms主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="Java"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>Java</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>SE</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="JavaSE基础" class="vp-link nav-link active nav-link active" href="/Java/SE/"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>JavaSE基础<!----></a></li><li class="dropdown-subitem"><a aria-label="Java语法" class="vp-link nav-link active nav-link active" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html"><span class="font-icon icon fa-fw fa-sm fas fa-ellipsis" style=""></span>Java语法<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a aria-label="算法" class="vp-link nav-link nav-link" href="/Algorithm/"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>算法<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="文章上传手册" class="vp-link nav-link nav-link" href="/guide/manual/git%E5%8D%8F%E5%90%8C%E4%B8%8A%E4%BC%A0%E6%96%87%E7%AB%A0%E6%89%8B%E5%86%8C.html"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>文章上传手册<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/LSauce/JavaFarms" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><!--[--><a aria-label="JavaFarms主页" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>JavaFarms主页<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">Java</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><span class="vp-sidebar-title">JavaSE基础</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="0.git使用" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/0_git%E4%BD%BF%E7%94%A8.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>0.git使用<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="0.IDEA安装与设置" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/0_IDEA%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>0.IDEA安装与设置<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="0.Java基本介绍" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/0_Java%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>0.Java基本介绍<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="0.常用软件" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/0_%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>0.常用软件<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="02.方法" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/2_%E6%96%B9%E6%B3%95.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>02.方法<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="03.补充递归" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/3_%E8%A1%A5%E5%85%85%E9%80%92%E5%BD%92.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>03.补充递归<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="04.面向对象基础" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/4_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>04.面向对象基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="05.面向对象三大特征" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>05.面向对象三大特征<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="06.面向对象设计" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>06.面向对象设计<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="引例" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#引例"><!---->引例<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="定义" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#定义"><!---->定义<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="特点与使用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#特点与使用"><!---->特点与使用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="注意事项" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#注意事项"><!---->注意事项<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="练习" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#练习"><!---->练习<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="引例" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#引例-1"><!---->引例<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="定义" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#定义-1"><!---->定义<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="优点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#优点"><!---->优点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="特点和使用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#特点和使用"><!---->特点和使用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="extends VS implements" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#extends-vs-implements"><!---->extends VS implements<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="默认方法和静态方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#默认方法和静态方法"><!---->默认方法和静态方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="练习" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#练习-1"><!---->练习<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="方法的形参和返回值类型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#方法的形参和返回值类型"><!---->方法的形参和返回值类型<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="方法传值" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#方法传值"><!---->方法传值<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="方法的返回值" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#方法的返回值"><!---->方法的返回值<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="方法重写中的返回值类型问题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#方法重写中的返回值类型问题"><!---->方法重写中的返回值类型问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="链式调用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#链式调用"><!---->链式调用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="引例" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#引例-2"><!---->引例<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="定义与分类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#定义与分类"><!---->定义与分类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="成员内部类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#成员内部类"><!---->成员内部类<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="自身特点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#自身特点"><!---->自身特点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="成员内部类的访问特点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#成员内部类的访问特点"><!---->成员内部类的访问特点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="练习" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#练习-2"><!---->练习<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="静态内部类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#静态内部类"><!---->静态内部类<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="自身特点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#自身特点-1"><!---->自身特点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="静态内部类访问特点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#静态内部类访问特点"><!---->静态内部类访问特点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="注意事项" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#注意事项-1"><!---->注意事项<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="练习" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#练习-3"><!---->练习<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="局部内部类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#局部内部类"><!---->局部内部类<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="自身特点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#自身特点-2"><!---->自身特点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="局部内部类的访问特点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#局部内部类的访问特点"><!---->局部内部类的访问特点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="局部内部类的经典使用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#局部内部类的经典使用"><!---->局部内部类的经典使用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="注意事项" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#注意事项-2"><!---->注意事项<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="内部类的优缺点和使用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#内部类的优缺点和使用场景"><!---->内部类的优缺点和使用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="内部类对象" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#内部类对象"><!---->内部类对象<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="概述" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#概述"><!---->概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="匿名内部类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#匿名内部类"><!---->匿名内部类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="lambda表达式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html#lambda表达式"><!---->lambda表达式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a aria-label="08.补充其他常用类" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/8_%E8%A1%A5%E5%85%85%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%B1%BB.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>08.补充其他常用类<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="09.String" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/9_String.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>09.String<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="10.异常" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/10_%E5%BC%82%E5%B8%B8.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>10.异常<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="11.File" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/11_File.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>11.File<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="12.IO" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/12_IO.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>12.IO<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="14.网络编程" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/14_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>14.网络编程<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="15.反射" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/15_%E5%8F%8D%E5%B0%84.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>15.反射<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="16.注解" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/16_%E6%B3%A8%E8%A7%A3.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>16.注解<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="17.GC" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/17_GC.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>17.GC<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul></section></li><li><!--[--><a aria-label="幻灯片页" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/slides.html"><span class="font-icon icon fa-fw fa-sm fas fa-person-chalkboard" style=""></span>幻灯片页<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span><span class="vp-sidebar-title">指南</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><span class="vp-sidebar-title">算法</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>06.面向对象设计</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://jf.kiroe.cn" target="_blank" rel="noopener noreferrer">JavaFarmer</a></span><span property="author" content="JavaFarmer"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 59 分钟</span><meta property="timeRequired" content="PT59M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category1" role>JavaSE</span><!--]--><meta property="articleSection" content="JavaSE"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#引例">引例</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#定义">定义</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#特点与使用">特点与使用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#注意事项">注意事项</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#练习">练习</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#引例-1">引例</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#定义-1">定义</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#优点">优点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#特点和使用">特点和使用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#extends-vs-implements">extends VS implements</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#默认方法和静态方法">默认方法和静态方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#练习-1">练习</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#方法的形参和返回值类型">方法的形参和返回值类型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#方法传值">方法传值</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#方法的返回值">方法的返回值</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#方法重写中的返回值类型问题">方法重写中的返回值类型问题</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#链式调用">链式调用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#引例-2">引例</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#定义与分类">定义与分类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#成员内部类">成员内部类</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#自身特点">自身特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#成员内部类的访问特点">成员内部类的访问特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#练习-2">练习</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#静态内部类">静态内部类</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#自身特点-1">自身特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#静态内部类访问特点">静态内部类访问特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#注意事项-1">注意事项</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#练习-3">练习</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#局部内部类">局部内部类</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#自身特点-2">自身特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#局部内部类的访问特点">局部内部类的访问特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#局部内部类的经典使用">局部内部类的经典使用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#注意事项-2">注意事项</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#内部类的优缺点和使用场景">内部类的优缺点和使用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#内部类对象">内部类对象</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#概述">概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#匿名内部类">匿名内部类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#lambda表达式">lambda表达式</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h1><p>学习目标:</p><ul><li>掌握抽象类的定义</li><li>掌握抽象类的特点与使用</li></ul><h2 id="引例" tabindex="-1"><a class="header-anchor" href="#引例" aria-hidden="true">#</a> 引例</h2><p>以下猫狗继承案例，是一个非常基础的继承语法的代码。思考一下Animal类的继承体系，有什么问题吗？</p><p>从以下两个角度分析：</p><ol><li>从代码角度上，有没有冗余代码？</li><li>从设计角度上，在这个案例中，会存在一个动物对象吗？</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;动物叫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;猫叫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;狗叫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析一下</p><ol><li><p>单纯从代码角度上，有没有冗余代码？</p><p>实际上是有的。从方法调用的角度考虑，Animal类当中的shout方法从来没有被调用过。该方法单纯就是让子类继承并重写的，它实际上没有被调用的需求。从最理想的角度上来说，它的方法体是可以去掉的，仅保留一个声明让子类去重写就可以了。</p></li><li><p>当然代码多几行少几行并不重要，重要是：从设计角度出发，Animal类是一个抽象的概念，用于指代所有动物。程序中根本不需要创建它的对象。而且对于一个抽象的概念，也不应该、也不可能去描述它的行为。</p></li></ol><p>综上，我们提出两个改进的方向：</p><ol><li>Animal类就是作为顶层抽象祖先类而存在的，不需要创建对象，于是干脆不要创建对象了。</li><li>Animal类当中的shout方法不需要方法体，仅用于作为被继承和重写一个方法声明。</li></ol><p><strong>当父类的某些方法, 需要声明, 但是又不确定如何实现时, 可以将其声明为抽象方法, 那么这个类就是抽象类</strong></p><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><p>按照上述构想我们首先把方法的方法体去掉，这样就得到一个抽象方法。它的语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>修饰符列表<span class="token punctuation">]</span> <span class="token keyword">abstract</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注：</p><ol><li>抽象方法没有方法体，只有方法的声明（方法头）。但是不要忘记写分号&quot;;&quot;。</li><li><span style="color:red;background:yellow;"><strong>抽象方法必须写在一个抽象类中。</strong></span></li></ol><p>接下来，我们定义抽象类。它的语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>修饰符列表<span class="token punctuation">]</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> 类名<span class="token punctuation">{</span>
    <span class="token comment">//类体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过测试，我们发现抽象类不能创建对象，但抽象类可以继承，存在子类。并且抽象类作为父类，多态现象仍然存在。</p><p><span style="color:red;background:yellow;"><strong>在继承体系中，从祖先类开始，随着一个个子类的定义，子类变得越来越具体，而祖先类则更具有一般性和抽象性。在这种情况下，为了体现祖先类在设计上的抽象性，我们只将该类作为派生其他类的父类，而不能创建对象实例。这个时候，这样的类，我们称之为抽象类。</strong></span></p><img src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201071337543.png?align=center" alt="抽象类继承图" style="zoom:20%;"><p><strong>上层的类越来越抽象，下层的类越来越具体。</strong></p><h2 id="特点与使用" tabindex="-1"><a class="header-anchor" href="#特点与使用" aria-hidden="true">#</a> 特点与使用</h2><p><strong>特点</strong></p><p>抽象类的特点我们主要从以下角度：</p><ol><li>类名命名特点是什么?</li><li>能用哪些修饰符？</li><li>成员特点 <ol><li>普通成员</li><li>静态成员</li><li>抽象方法</li></ol></li><li>构造器</li><li>代码块</li></ol><p><strong>测试以后，结论如下：</strong></p><ul><li><p>抽象类仍然是一个类，它的命名仍然需要遵循大驼峰的命名规范。当然，它比较特殊，许多公司的开发规范中，会要求将抽象类命名为<code>AbstracXxx</code>或<code>BaseXxx</code>，用于表示该类是一个抽象类。这是一个不错的命名习惯，推荐使用，但不强制。</p></li><li><p>类class在定义时，本身可以使用的修饰符就比较少，除了访问权限修饰符之外，几乎就只有final、abstract等少数修饰符。但是但是final和abstract在修饰类时是冲突的，不能放在一起使用。final是阻止继承而abstract是抽象类，如果不继承抽象类没有任何意义。</p></li><li><p>抽象类的成员特点：</p><ol><li><p>成员变量。抽象类可以定义普通类中能够定义的所有成员变量，在这一点上，和普通类是一样的。</p></li><li><p>成员方法。抽象类可以定义普通类中能够定义的所有成员方法，包括普通成员方法和静态成员方法，在这一点上，和普通类仍然是一样的</p><p>注：抽象类虽然不能创建对象，但是它有子类，这些具体实现方法可以让子类继承，子类可以选择直接使用，也可以选择重写，选择的权力在子类手上（假如一个方法在抽象类的多个子类中都需要被使用，那么就可以提取到抽象类中作为一个默认实现）</p><p>综上，不能发现： <span style="color:red;background:yellow;"><strong>普通类中能够定义的成员，在抽象类中都是可以定义的。</strong></span></p></li><li><p>抽象方法。首先抽象类可以没有抽象方法，但是如果一个抽象类没有抽象方法，那么它就没有必要声明为抽象，直接声明为普通类就够了。<!---->抽象方法最重要的作用是起到 <span style="color:red;background:yellow;"><strong>&quot;占位&quot;</strong></span> 的作用，任何普通类继承了该抽象类，都必须实现该抽象方法（强制的）</p><p>如果子类不想实现抽象父类中的抽象方法，可以把子类也设置为抽象类，抽象类就不需要实现父类中的抽象方法了。</p></li></ol></li><li><p>构造器。构造器除了可以自己用，创建对象时给成员变量赋值，还可以给子类用，在子类对象初始化过程中，可以调用父类的构造方法给父类的成员变量赋值。所以抽象类虽然不能创建对象，但它也是有构造器的。实际上，<span style="color:red;background:yellow;"><strong>在Java中，任何一个类都有构造器。</strong></span></p></li><li><p>代码块，无论是构造代码块，还是静态代码块，都有。</p></li></ul><p>综上：抽象类实际上和普通类能够定义的成员是一样的，普通类中有的东西它都有，只不过多了一个抽象方法。<span style="color:red;background:yellow;"><strong>在不考虑创建对象的情况下，直接把一个类声明为abstract，是不会编译报错的。</strong></span></p><hr><p><strong>使用</strong></p><p><strong>抽象类的使用，我们主要探讨，它的子类特点。</strong></p><p>抽象类的子类可以有两种情况：</p><ol><li>子类是普通类，普通类继承抽象类，必须实现所有的抽象方法。</li><li>子类是抽象类，抽象子类不需要实现抽象方法，抽象子类可以自由选择实现（或实现或不实现）。</li></ol><p>注：抽象类还可以继承一个普通类, 实际上如果一个抽象类, 它没有直接父类, 那它就直接继承Object</p><h2 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h2><ol><li><p>abstract关键字，不能用来修饰构造器、属性、代码块等结构。只能修饰类或者方法。</p></li><li><p>abstract修饰类时，类的修饰符不能有final。</p></li><li><p>abstract修饰方法时，该方法不能有修饰符：</p><ol><li>private</li><li>static</li><li>final</li></ol></li><li><p>一个抽象类中可以没有抽象方法，但是没有意义</p></li></ol><h2 id="练习" tabindex="-1"><a class="header-anchor" href="#练习" aria-hidden="true">#</a> 练习</h2><blockquote><p>普通员工包含3个属性：姓名、工号以及工资，行为是工作</p><p>程序员包含3个属性：姓名、工号以及工资，行为是工作和加班（overtime work）</p><p>经理包含4个属性：姓名、工号、工资以及奖金（bonus），行为是工作</p></blockquote><ul><li>请使用所学的知识设计该员工系统</li><li>要求类中提供必要的方法进行属性访问（description）</li></ul><p>类图结构</p><figure><img src="/assets/image-20221205144500325-6952a6dd.png" alt="image-20221205144500325" tabindex="0" loading="lazy"><figcaption>image-20221205144500325</figcaption></figure><ol start="2"><li>抽象类的作用是：做为继承体系中的顶层父类、祖先类而存在的。说白了所有继承了该抽象类的对象，都应该是一个该抽象类的对象。比如我定义了一个抽象的Person类，那么Student、Teacher等继承它是没问题的，但是让一个Cat继承就不行了（即便有成员可以复用）。<!----></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 抽象的员工类</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BaseStaff</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">BaseStaff</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 定义打印属性的方法,子类可以选择直接使用,也可以选择重写</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printStaff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;id是&quot;</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">&quot;的员工,姓名是&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;,Ta的工资是&quot;</span> <span class="token operator">+</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> salary<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">NormalStaff</span> <span class="token keyword">extends</span> <span class="token class-name">BaseStaff</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">NormalStaff</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> id<span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;负责杂项工作&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Coder</span> <span class="token keyword">extends</span> <span class="token class-name">BaseStaff</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Coder</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> id<span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;负责技术开发&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">overTimeWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;996福报,蹭公司电,蹭公司网!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">BaseStaff</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> bonus<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">,</span> <span class="token keyword">double</span> bonus<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> id<span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>bonus <span class="token operator">=</span> bonus<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;负责统筹规划&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printStaff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;id是&quot;</span> <span class="token operator">+</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;的员工,姓名是&quot;</span> <span class="token operator">+</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;,Ta的工资是&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> bonus<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h1><p>学习目标:</p><ul><li>掌握接口的定义</li><li>掌握接口的特点与使用</li></ul><h2 id="引例-1" tabindex="-1"><a class="header-anchor" href="#引例-1" aria-hidden="true">#</a> 引例</h2><p>在之前的猫狗案例中，我们将Animal类设置为抽象类，继承体系代码如下：</p><p>猫狗案例代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;猫叫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;狗叫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们有了新需求：一部分猫和狗，经过了特殊训练，能够<mark>直立行走</mark>了。那么这群特殊的猫和狗，怎么描述它们呢？</p><p>分析：</p><p>部分猫和狗经过特殊训练，才能够直立行走。所以不可能直接加个方法到Cat类和Dog类中，不是所有猫狗都有这个行为。而特殊的猫狗仍然是猫和狗，所以它们肯定还要继承猫和狗这两个类。可能很多同学，这时候想到的就是：重新定义两个新的猫狗类（比如超级狗和猫）继承猫狗，然后给出直立行走的方法就算完事了。这样做不是不行，需求是实现了，但还有一些小问题：</p><ol><li>一方面没有体现代码复用。</li><li>更重要的是，没有体现出特殊训练的过程。假如还有一些动物也要直立行走，增加这个行为，如何体现出规范性、标准性呢？体现出它们是特殊的经过训练的动物呢？</li></ol><p>这里我们想到了抽象类，因为抽象类中抽象方法，可以强制约束子类实现它，这样就是一种标准和规范，体现了它经过了特殊训练，和之前不同了。</p><p>于是我们定义抽象类，给出抽象方法，让超级猫狗类去继承这个抽象类，可行吗？</p><p>理想很美好，现实很骨感。显然做不到，因为Java不支持多继承。除开这点这么做也不是完美的，问题是：</p><ol><li>这个抽象类里面是对功能和行为的抽象，缺少属性（单独一个直立行走的行为是一个什么对象？）所以单独的行为不应该被抽象为类，不符合类的定义。</li><li>继承这个抽象类也不符合继承的&quot;is-a&quot;关系，这里不适用继承（还是上面那句话，行为根本不是个体）</li></ol><p>于是，我们就迫切需要一种全新的数据类型，这种全新的数据类型：</p><ol><li>不强调属性，只强调行为的抽象，&quot;继承&quot;它表示功能的扩展。</li><li>在一个类继承某个类后，还能继续&quot;继承&quot;，不受Java单继承限制。</li><li>没有&quot;is-a&quot;这种继承关系的限制。</li><li>最好还有抽象方法。（因为它能表示规范和标准）</li></ol><p>这种全新的数据类型，就是<strong>接口（interface）</strong>。</p><p>如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们实现这个接口，各自实现自己具体的处理方法来处理那个目标</p><h2 id="定义-1" tabindex="-1"><a class="header-anchor" href="#定义-1" aria-hidden="true">#</a> 定义</h2><p>上面四条，其实已经描述了接口的特点，接口是一种表示对行为抽象的，不受Java多继承限制的，用来作为功能扩展标准的一种引用数据类型。它的定义语法如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">interface</span> 接口名<span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：</p><ul><li><p>接口的访问权限修饰符也只有两种：</p><ol><li>public</li><li>默认缺省的</li></ol></li><li><p>接口名和类名一样，遵循大驼峰式的书写规范，接口名最好起的见名知意。有些程序员喜欢在接口前加一个大写字母I来直接，表示该类型是一个接口，可以借鉴，但不强制。</p></li><li><p>接口中可以定义抽象方法，和抽象类中定义抽象方法没有区别。</p></li><li><p>接口是可以被一个类&quot;继承&quot;的，接口的&quot;继承&quot;，更准确、常见的叫法称之为接口的实现。当然它也不再使用extends关键字，而是使用 implements 关键字。一个普通类实现接口必须实现所有抽象方法。它的语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> 类名 <span class="token keyword">extends</span> 类名 <span class="token keyword">implements</span> 接口名 <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>细节问题：如果一个类实现接口并继承别的类，要&quot;<mark>先继承再实现</mark>&quot;。关键字位置不要写反了。</p></li><li><p>在接口的实现中，可以称呼接口为&quot;父接口&quot;，接口的实现类为&quot;子类&quot;，它们仍然是父子关系。当然多态现象仍然能够发生。</p></li><li><p>接口不受多继承限制，一个类可以在继承别的类的同时实现接口，而且可以实现多个接口。</p></li></ul><h2 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h2><p>使用接口有如下优点：</p><ul><li>接口<mark>不受单继承限制</mark>，这是接口非常重要的优点。</li><li>接口不是类，它和它的实现类，也不需要存在&quot;is-a&quot;关系，接口比抽象类的使用更加灵活。 <ul><li>程序开发中将接口和它的实现类之间的关系，称之为&quot;like-a&quot;关系。只要是<mark>实现了Xxx的功能，就像Xxx</mark>。</li></ul></li><li>接口表示一种开发标准，一种规范。表示对功能的扩展，它只关注行为，不关注属性。</li></ul><h2 id="特点和使用" tabindex="-1"><a class="header-anchor" href="#特点和使用" aria-hidden="true">#</a> 特点和使用</h2><p><strong>接口的特点我们主要研究以下方面</strong></p><ol><li>接口的声明特点 <ol><li>接口能不能创建对象?</li><li>接口能不能用final修饰?</li></ol></li><li>接口的实现类的书写格式</li><li>成员特点 <ol><li>能否定义属性(成员变量, 静态成员变量, 全局常量)?</li><li>能否定义方法/行为?</li></ol></li><li>构造器</li><li>代码块</li></ol><p><strong>测试后，我们的结论是：</strong></p><ul><li><p><strong>接口的声明特点</strong></p><ul><li>接口能不能创建对象? <ul><li>不能创建对象,实际上接口是抽象的. 因为接口的声明修饰符中隐含了关键字abstract</li></ul></li><li>接口能不能用final修饰? <ul><li>不能,接口定义出来目的就是为了被实现. final天生和接口矛盾</li></ul></li></ul></li><li><p><strong>接口的命名特点(非强制)</strong></p><ul><li>接口在命名时,为了体现接口的特殊性,表示它是一个接口. 某些程序员会在接口的命名前加大写字母&quot;I&quot;</li></ul></li><li><p><strong>接口的实现类的书写格式(非强制)</strong></p><ul><li>某些程序员会在接口的所在位置,定义一个全新的包,叫&quot;impl&quot;</li><li>然后在该包下写接口的实现类,命名为&quot;接口名 + Impl&quot;</li></ul></li><li><p><strong>成员特点</strong></p><ul><li>能不能定义属性?(成员变量,静态成员变量,全局常量) <ul><li>可以定义,但是接口中的属性默认都是&quot;public static final&quot;修饰的公共的全局常量</li><li>这些隐含的修饰符不要写出来, 接口能够定义的所有结构的访问权限都是public, 而且public是隐含的修改不了</li><li>接口中没有静态代码块,接口中的全局常量,必须显式赋值</li><li>接口表示对功能的扩展,所以接口往往只有对行为的抽象(接口往往只有方法),接口是非常少见定义属性的, 只有当接口的所有实现类,都需要一个共同的全局常量时才考虑在接口中定义属性.</li></ul></li><li>能不能定义方法/行为? <ul><li>可以定义方法,但是接口中的方法默认都是&quot;public abstract&quot;修饰的公共的抽象方法</li><li>实际上,在Java8之前,接口中没有任何实现方法,接口中只能定义抽象方法</li><li>特别强调: 实际开发中,99%的情况下,接口就只有光秃秃的抽象方法定义,没有其他任何内容</li></ul></li></ul></li><li><p><strong>构造器</strong></p><ul><li>接口是没有构造器的,接口自己用不到构造器</li></ul><ul><li><pre><code>     接口的子类也用不到
</code></pre></li></ul></li><li><p><strong>代码块</strong></p><ul><li>没有静态代码块</li></ul><ul><li><pre><code>     没有构造器就没有构造代码块
</code></pre></li></ul></li><li><p><strong>以上总结,接口能定义的结构特点:</strong></p><ul><li>可以定义<mark>全局常量</mark></li></ul><ul><li><pre><code>     可以定义==抽象方法==(Java8以后允许实现方法)
</code></pre></li></ul><ul><li>实际上,接口往往只有抽象方法定义,它表示对行为的抽象, 表示制定标准和规范</li></ul></li></ul><p><strong>注意两个问题:</strong></p><ol><li>实现接口的类，如果没有明确继承一个其他类，那么子类对象的隐式初始化super()指向Object类。</li><li>接口虽然不是类，但是它也<mark>继承了Object类</mark>。</li></ol><p><strong>接口的使用，我们主要探讨它的子类特点。</strong></p><p>接口的子类可以是什么？</p><ol><li><p>普通类实现接口，必须实现所有的抽象方法。</p></li><li><p>抽象类实现接口，<mark>按需实现抽象方法</mark>。</p></li><li><p>接口可以继承一个接口，并且接口在继承接口后，可以重写父接口中的抽象方法和默认方法。 <mark>接口之间可多继承extends</mark></p><p>参考如下代码（了解即可）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
   
<span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
        重写父接口抽象方法
            只有在父接口的方法返回值类型是父类类型时
            子接口中可以将抽象方法返回值类型重写为子类类型
            其余地方都不可变。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">Demo</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="extends-vs-implements" tabindex="-1"><a class="header-anchor" href="#extends-vs-implements" aria-hidden="true">#</a> extends VS implements</h2><p>实现（Implement）：如果多个类处理的目标是一样的，但是<mark>处理的方法方式</mark>不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标</p><p>继承: 指的是一个类（称为子类）继承另外的一个类（称为父类）的功能，并可以增加它自己的新功能的能力。所以，继承的根本原因是因为要复用，而实现的根本原因是<mark>需要定义一个标准</mark></p><blockquote><p>简单点说，就是同样是一台汽车，既可以是电动车，也可以是汽油车，也可以是油电混合的，只要实现不同的标准就行了，但是一台车只能属于一个品牌，一个厂商。</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token keyword">extends</span> <span class="token class-name">Benz</span> <span class="token keyword">implements</span> <span class="token class-name">GasolineCar</span><span class="token punctuation">,</span> <span class="token class-name">ElectroCar</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
我们定义了一辆汽车，他实现了电动车和汽油车两个标准，但是他属于奔驰这个品牌。像上面这样定义，我们可以最大程度的遵守标准，并且复用奔驰车所有已有的一些功能组件。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>继承（extends）是不能跨越种族的，类和类继承，<mark>接口和接口继承</mark>，<mark>接口和类之间没有继承关系</mark>。</p><ol><li>普通类继承一个抽象类，需要实现里面的所有抽象方法。</li><li>抽象类继承一个抽象类，按需实现里面的抽象方法。</li><li>抽象类继承一个普通类，是可以的。</li><li>接口在继承一个接口后，会得到接口的所有抽象方法。</li><li>类的继承是单继承的，<mark>接口的继承是多继承</mark>的。</li></ol><p>实现（implements），必须发生在<mark>类与接口</mark>之间，接口和类是没有任何关系的。</p><ol><li>普通类实现接口，必须实现所有抽象方法</li><li><mark>抽象类实现接口，按需实现抽象方法</mark></li></ol><h2 id="默认方法和静态方法" tabindex="-1"><a class="header-anchor" href="#默认方法和静态方法" aria-hidden="true">#</a> 默认方法和静态方法</h2><p><strong>Java8中接口的语法迎来了大的变动，新增了两种具有方法体的实现方法：</strong></p><ul><li>默认方法</li><li>静态方法</li></ul><ol><li><p>默认方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 默认方法的语法:</span>
<span class="token keyword">default</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//方法体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>接口中的<mark>默认方法的访问权限修饰符是public</mark>，不可更改。全局变量和抽象方法，默认方法，静态方法都为 public</li><li>默认方法的作用： <ul><li>抽象类中的实现方法是用来作为子类的默认实现的，但是接口不具备这个功能。接口表示对功能的扩展，它更多的是一种标准和规范，多数情况下它不需要实现方法。</li><li>Java8仍然新增了默认方法，主要是两个角度考虑: <ul><li>接口中一旦有了默认实现方法，<mark>程序设计接口的灵活性</mark>就增加了。在没有默认方法时，接口中一旦新增任何方法，子类都必须实现它。而现在有了默认方法，就不需要这么做：需要实现的就自己重写，不需要的就直接继承。代码的兼容性和灵活性就增加了。</li><li>Java8中引入了Lambda表达式和StreamAPI，接口中的默认方法可以作为它们的实现，完成<mark>函数式编程</mark>。（这个仅了解，后面会讲Lambda表达式）</li></ul></li><li>接口中的默认方法，还可以配合接口的&quot;多实现&quot;，实现真正意义上的多继承。</li></ul></li></ul></li><li><p>静态方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//方法体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>接口中的静态方法也是<mark>默认public修饰</mark>的，不可更改。</li></ul></li></ol><ul><li>它的调用方式是用接口名.静态方法名。 <ul><li>接口中的静态方法也是为了<mark>配合Lambda表达式和StreamAPI</mark>使用的，其余场景不多见。</li><li>接口自从Java8以后有了静态方法，甚至可以写一个main方法。</li><li><strong>接口中的静态实现方法，只能自己用，不能用实现类类名调用。</strong></li></ul></li></ul><hr><p><strong>上面两种方法仅供了解，实际开发中，可能会偶尔见到它，但自己写的概率非常小。</strong></p><h2 id="练习-1" tabindex="-1"><a class="header-anchor" href="#练习-1" aria-hidden="true">#</a> 练习</h2><ol><li>教练（Coach）和运动员（Sportsman）案例</li></ol><blockquote><p>小试牛刀请用所学知识分析：这个案例中有哪些抽象类，哪些接口，哪些具体类。</p></blockquote><p>现在有乒乓球运动员和篮球运动员，乒乓球教练和篮球教练。为了能够出国交流，跟乒乓球相关的人员都需要学习英语。</p><ol start="2"><li><span style="color:red;background:yellow;font-size:文字大小;font-family:字体;"><strong>(重要)</strong></span>某电商系统后台，前端程序员需要后端程序员，提供接口来完成商品的管理，展示页面。假如前后端商量好，要求能实现CRUD操作, 采用MVC分层思想, 业务逻辑如下: <ul><li>展示全部商品（Products）页面时，将仅装有商品对象的数组返回，前端不提供任何数据。</li><li>新增商品时，前端提供商品各种参数，后端需要校验ID唯一性，然后将对象插入数组，返回插入结果(true/false)。</li><li>查询商品, 前端提供商品ID或者商品名称(可根据ID查询或者根据商品名称查询), 后端根据信息查询商品详情, 并返回结果(商品对象)</li><li>更新商品(每次更新商品中的一个信息即可), 前端提供要被更新的商品ID, 以及新的产品信息(可以用数组的形式存储新的产品信息), 后端根据商品ID找到该商品, 并将新的信息替换, 返回该商品对象.</li><li>删除商品时，前端提供商品ID，后端将该商品删除后，返回删除结果。（成功返回true，根据ID找不到该商品即删除失败返回false）</li></ul></li></ol><h2 id="方法的形参和返回值类型" tabindex="-1"><a class="header-anchor" href="#方法的形参和返回值类型" aria-hidden="true">#</a> 方法的形参和返回值类型</h2><h3 id="方法传值" tabindex="-1"><a class="header-anchor" href="#方法传值" aria-hidden="true">#</a> 方法传值</h3><p>方法的形参在方法调用传入实参时，不一定要求数据类型完全一致。</p><ul><li>**基本类型：**对于基本数据类型的方法形参，存在自动类型提升。</li><li><strong>引用类型：</strong> 对于引用数据类型的方法传参，存在自动向上转型。 <ol><li>形参如果写一个普通类：调用方法时需要传入的是该类的对象或者该类的子类对象</li><li>形参如果写一个抽象类：调用方法时需要传入的是该抽象类的子类对象</li><li>形参如果写一个接口：调用方法时需要传入的是该接口的子类对象</li></ol></li></ul><h3 id="方法的返回值" tabindex="-1"><a class="header-anchor" href="#方法的返回值" aria-hidden="true">#</a> 方法的返回值</h3><p>方法的返回值类型，和在方法体中返回具体值（对象）时，不一定要求数据类型完全一致。</p><ul><li>**基本类型：**方法体中，返回一个具体的值不要求和返回值类型完全一致，存在自动类型提升。</li><li><strong>引用类型：</strong> 在方法体中，返回一个对象时不要求就是返回值类型的对象，存在自动向上转型。 <ol><li>返回值类型如果写一个普通类：可以返回该类的对象或者该类的子类对象</li><li>返回值类型如果写一个抽象类：返回该抽象类的子类对象。</li><li>返回值类型如果写一个接口：返回该接口的子类对象。</li></ol></li></ul><h3 id="方法重写中的返回值类型问题" tabindex="-1"><a class="header-anchor" href="#方法重写中的返回值类型问题" aria-hidden="true">#</a> 方法重写中的返回值类型问题</h3><p>父子类方法重写中，方法声明中返回值类型的书写。</p><ol><li>**基本类型和void：**必须保持一模一样，不存在类型提升。</li><li>**引用类型：**不必保持一模一样，存在自动向上转型。 <ol><li>类：父类中的方法返回一个普通类类型 <ul><li>子类方法中可以返回该类型</li><li>也可以返回该类的子类类型</li></ul></li><li>抽象类：父类中的方法返回一个抽象类类型 <ul><li>子类方法可以返回该类型</li><li>也可以返回抽象类的实现类类型</li></ul></li><li>接口：父类中的方法返回一个接口类型 <ul><li>子类方法可以返回该类型</li><li>也可以返回接口的实现类类型</li></ul></li></ol></li></ol><h2 id="链式调用" tabindex="-1"><a class="header-anchor" href="#链式调用" aria-hidden="true">#</a> 链式调用</h2><p>链式调用，在Java代码中是很常见的。当然它不是一个语法，这里讲一下它的形式，大家知道即可。</p><p>对于类Studnet：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>

 <span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">public</span> <span class="token class-name">Teacher</span> <span class="token function">getTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;秀一波~~~&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如在main方法中写以下代码（不使用链式调用）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">StudentDemo</span> sd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StudentDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span> s <span class="token operator">=</span> sd<span class="token punctuation">.</span><span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用链式调用的形式为：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">StudentDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><span style="color:red;background:yellow;"><strong>链式调用的本质在于：前面方法的返回值是一个对象。</strong></span></p><h1 id="接口-vs-抽象类" tabindex="-1"><a class="header-anchor" href="#接口-vs-抽象类" aria-hidden="true">#</a> 接口 VS 抽象类</h1><p>接口和抽象类的异同：</p><table><thead><tr><th style="text-align:center;">编号</th><th style="text-align:center;"><strong>区别点</strong></th><th style="text-align:center;"><strong>抽象类</strong></th><th style="text-align:center;"><strong>接口</strong></th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;">定义</td><td style="text-align:center;">包含抽象方法的类</td><td style="text-align:center;">抽象方法和全局常量的集合</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;">组成</td><td style="text-align:center;">构造方法、抽象方法、普通方法、常量、变量</td><td style="text-align:center;">常量、抽象方法、(jdk8:默认方法、静态方法)</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;">使用</td><td style="text-align:center;">子类继承抽象类(extends)</td><td style="text-align:center;">子类实现接口(implements)</td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;">关系</td><td style="text-align:center;">抽象类可以实现多个接口</td><td style="text-align:center;">接口不能继承抽象类，但允许继承多个接口</td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;">对象</td><td style="text-align:center;">不能创建对象，但是有构造方法</td><td style="text-align:center;">不能创建对象，也没有构造方法</td></tr><tr><td style="text-align:center;">6</td><td style="text-align:center;">局限</td><td style="text-align:center;">抽象类不能被多继承</td><td style="text-align:center;">接口之间能多继承，能被多实现</td></tr><tr><td style="text-align:center;">7</td><td style="text-align:center;">思想</td><td style="text-align:center;">作为模板或对共性属性和行为抽象，is-a</td><td style="text-align:center;">作为标准或对共性行为抽象，like-a</td></tr><tr><td style="text-align:center;">8</td><td style="text-align:center;">访问权限</td><td style="text-align:center;">抽象类的成员，写访问权限比较自由。</td><td style="text-align:center;">接口的成员，必须是public修饰的</td></tr><tr><td style="text-align:center;">9</td><td style="text-align:center;">选择</td><td style="text-align:center;"><strong>如果抽象类和接口都可以使用的话，优先使用接口，避免单继承的局限</strong></td><td style="text-align:center;"></td></tr></tbody></table><p>总之，抽象类和接口除了都是抽象外，区别相当明显。抽象类是作为继承层次中的顶层父类存在的，接口则比较自由。</p><h1 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类" aria-hidden="true">#</a> 内部类</h1><ul><li>熟悉不同内部类的语法</li><li>熟悉不同内部类的访问特点</li></ul><h2 id="引例-2" tabindex="-1"><a class="header-anchor" href="#引例-2" aria-hidden="true">#</a> 引例</h2><p>引例</p><blockquote><p>我们现在做一个应用程序，需要描述一台电脑中的CPU，对于电脑而言，该怎么去描述这个CPU呢？</p></blockquote><p>分析：</p><p>我们可以创建两个类，一个描述Computer，一个描述CPU。但这样明显是有问题的：</p><ol><li>CPU是电脑中最重要的组件，但它脱离电脑存在就是一粒沙子。这意味着CPU对象，应仅存在于Computer内部。</li><li>CPU可以控制计算机的一切硬件资源。这意味CPU对象能够操控，Computer类中的所有成员，无论私有。</li></ol><p>定义普通类CPU是不能完成需求的，因为：</p><ol><li>普通类没有私有概念，不可能控制仅能在Computer内部创建对象。</li><li>普通类不可能直接访问，其它类的私有成员。</li></ol><p><strong>显然CPU类不应该是一个普通类，不应该是一个独立的类 ---&gt; 不再将CPU类定义为一个独立的类，而是将它放入Computer类的类体中，可以近似的看成是一个Computer类的成员 ---&gt; CPU类近似看成Computer类的成员，于是：</strong></p><ol><li>在其它类内部的类，就有了私有概念，就有了四种访问权限。只需要在内部私有化一个类，那么在外界就无法创建它的对象了。</li><li>既然已经成为了成员，成为了&quot;自己人&quot;，那么就不再受限于权限控制了，内部类就可以访问包裹它的类的所有成员，包括私有。</li></ol><p>上述两条，其实就是（成员）内部类的主要特点。也说明了使用内部类的主要场景：</p><ol><li>内部类是一种比类更加极致的封装思想体现，内部类的成员不仅被类自身保护，还被包裹着它的类保护。</li><li>内部类和包裹它的类互相成为了&quot;好兄弟&quot;，互相访问成员都不受访问权限限制。</li></ol><p>当你有以上使用场景时，就可以考虑使用内部类。</p><h2 id="定义与分类" tabindex="-1"><a class="header-anchor" href="#定义与分类" aria-hidden="true">#</a> 定义与分类</h2><p><strong>基本概念:</strong></p><p>在Java语言中类可以嵌套定义，广义的内部类指的是定义在另一类当中的一个类。</p><p><strong>分类:</strong></p><p>根据内部类在类中定义的位置不同:</p><ul><li><strong>成员位置</strong><ul><li>成员内部类</li><li>静态内部类</li></ul></li><li><strong>局部位置</strong><ul><li>局部内部类</li><li>匿名内部类</li><li>Lambda表达式</li></ul></li></ul><p>但是我们在学习的时候，不按定义位置来学习。我们按照它是一个类，还是一个对象来分类：</p><ol><li>语法定义了一个类，包括成员内部类、静态内部类和局部内部类。既然是定义了一个类，使用时还需要创建对象才能用。</li><li>语法直接创建了一个对象，包括匿名内部类和Lambda表达式。由于已经通过语法创建了对象，可以直接使用。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 外部类</span>
<span class="token keyword">class</span> <span class="token class-name">Computer</span><span class="token punctuation">{</span>
	<span class="token comment">// 内部类</span>
    <span class="token keyword">class</span> <span class="token class-name">CPU</span><span class="token punctuation">{</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 外部其他类</span>
<span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了上课方便，我们需要统一口径，在内部类课程当中，我们统一规定：</p><ol><li>像CPU这种，定义在别的类的内部的类，我们称之为内部类.</li><li>像Computer这种，包裹内部类的，我们称之为外部类.</li><li>Demo这种类我们称之为外部其他类.</li></ol><p>学习方式:<br> 1.定义的位置<br> 2.权限修饰符<br> 3.成员特点<br> 4.继承和实现<br> 5.访问特点<br> 内部类-----&gt;外部类<br> 外部类-----&gt;内部类<br> 内部类-----&gt;外部其他类<br> 外部其他类---&gt;内部类</p><h2 id="成员内部类" tabindex="-1"><a class="header-anchor" href="#成员内部类" aria-hidden="true">#</a> 成员内部类</h2><p>成员内部类是最普通的内部类，它定义在另一个类的成员位置， 可以看成<strong>该类的一个成员。</strong></p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//外部类</span>
<span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token class-name">OuterClazz</span><span class="token punctuation">{</span> 
<span class="token comment">//成员内部类</span>
	<span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token class-name">InnerClazz</span><span class="token punctuation">{</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自身特点" tabindex="-1"><a class="header-anchor" href="#自身特点" aria-hidden="true">#</a> 自身特点</h3><h4 id="访问权限修饰符" tabindex="-1"><a class="header-anchor" href="#访问权限修饰符" aria-hidden="true">#</a> 访问权限修饰符</h4><p><strong>成员内部类可以看成另一个类的成员，它和类中成员一样，有四种访问权限级别：</strong></p><ul><li>public</li><li>protected</li><li>缺省的，默认访问权限</li><li>private</li></ul><p>注：</p><ol><li>外部类可以保护成员内部类，如果想要访问一个成员内部类。首先需要外部类权限，然后还需要成员内部类权限。</li><li>都定义成员内部类了，多数情况下，应该私有化它。</li></ol><h4 id="成员特点" tabindex="-1"><a class="header-anchor" href="#成员特点" aria-hidden="true">#</a> 成员特点</h4><ol><li>可以定义普通成员变量，成员方法。但没有静态声明（包括静态变量，静态方法，静态代码块）</li><li>有构造器，有构造代码块。</li><li>可以有静态全局常量。</li></ol><p>注意:</p><ul><li>允许定义字面值常量赋值的全局常量, 也就是<mark>不会触发类初始化的全局常量</mark></li></ul><h4 id="继承和实现" tabindex="-1"><a class="header-anchor" href="#继承和实现" aria-hidden="true">#</a> 继承和实现</h4><ul><li>内部类可以继承和实现外部的类和接口。</li><li>也可以在类中定义多个普通类、抽象内部类和接口用来自己继承和实现。</li></ul><h3 id="成员内部类的访问特点" tabindex="-1"><a class="header-anchor" href="#成员内部类的访问特点" aria-hidden="true">#</a> 成员内部类的访问特点</h3><p>在具体了解成员内部类的使用之前,我们要搞清楚成员内部类和外部类之间,到底什么关系?</p><ul><li><p>成员内部类可以看成外部类的一个成员</p></li><li><p>类中的成员变量,必须依赖于类的对象而存在, 那么成员内部类的对象,也必须依赖于外部类对象而存在</p></li><li><p>也就是说,要想得到成员内部类对象,必须在外部类对象的基础上创建,成员内部类对象不能单独创建, 成员内部类依赖于外部类,反过来,没有依赖关系</p></li></ul><p>之所以存在这样的依赖关系:</p><p>是因为成员内部类对象的成员变量列表中,都会持有外部类对象的引用(成员内部类对象中保存了一个它所寄生的外部类对象的引用)</p><h4 id="成员内部类内部访问外部类-重点" tabindex="-1"><a class="header-anchor" href="#成员内部类内部访问外部类-重点" aria-hidden="true">#</a> 成员内部类内部访问外部类(重点)</h4><!----><p>在成员内部类的成员方法中访问外部类成员，因为外部类对象已经存在，所以可以直接访问，直接写成员的名字就可以了。在特殊情况下，当成员内部类成员和外部类成员同名时，如果仍然用成员名直接访问，访问的结果是成员内部类自身成员（就近原则），这时：</p><ol><li>在成员内部类的成员方法中，自身对象用this指向，用this点访问到的一定是自身成员。</li><li>在成员内部类的成员方法中，外部类对象用外部类类名.this指向，用外部类类名.this点访问到的一定是外部类成员。</li></ol><p>极限情况下，出现局部变量，成员内部类成员变量，外部类成员变量三者都同名的情况：</p><ol><li>就近原则直接写成员名字，访问的是局部变量的。</li><li>用this.访问的成员内部类自己的成员变量。</li><li>用外部类类名.this.访问的是外部类的成员变量。</li></ol><p>最后，如果全局常量同名了，就用类名去区分好了。</p><h4 id="外部类访问成员内部类成员-重点" tabindex="-1"><a class="header-anchor" href="#外部类访问成员内部类成员-重点" aria-hidden="true">#</a> 外部类访问成员内部类成员(重点)</h4><!----><p>第二，外部类访问成员内部类成员，要分两种情况：</p><ul><li><p>外部类的成员方法中访问成员内部类成员：</p><ol><li>因为这时成员内部类对象不存在，就需要先创建它的对象。</li><li>成员内部类对象依赖外部类对象而存在， 所以得先存在外部类对象才行。而恰好成员方法中隐含自身对象，所以这里创建成员内部类对象的方式就是—— <span style="color:red;background:yellow;"><strong>直接new创建。</strong></span></li></ol><p>创建对象后，直接用对象名点访问即可。如果有同名的情况，用成员内部类对象名访问的就是内部类的成员，反之不写对象名或者写this访问的都是外部类的成员。</p></li><li><p>外部类的静态成员方法中访问成员内部类成员：</p><ol><li><p>成员内部类对象不存在，就需要先创建它的对象。</p></li><li><p>成员内部类对象依赖外部类对象而存在， 所以得先存在外部类对象才行。但静态方法中什么对象都没有，就需要先创建外部类对象，再创建成员内部类对象。</p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">OuterClazz</span> outer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">InnerClazz</span> inner <span class="token operator">=</span> outer<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 上面等价于下面</span>
<span class="token class-name">InnerClazz</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到两个对象后，用谁的对象名访问的就是谁的成员。</p></li></ol></li></ul><h4 id="外部其他类访问成员内部类成员-了解" tabindex="-1"><a class="header-anchor" href="#外部其他类访问成员内部类成员-了解" aria-hidden="true">#</a> 外部其他类访问成员内部类成员(了解)</h4><p>外部其他类要访问成员内部类成员，条件要苛刻的多。由于成员内部类属于外部类的一个成员，所以首先外部其他类需要有外部类的访问权限，再次还需要成员内部类的访问权限。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">OuterClazz<span class="token punctuation">.</span>InnerClazz</span> oi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>创建对象后，用对象名访问成员即可。</strong></p><h4 id="成员内部类访问外部其他类成员-了解" tabindex="-1"><a class="header-anchor" href="#成员内部类访问外部其他类成员-了解" aria-hidden="true">#</a> 成员内部类访问外部其他类成员(了解)</h4><p>在成员内部类中访问外部类成员，和在普通类中访问其它类成员别无二致：</p><ol><li>静态成员直接类名点访问。</li><li>普通成员需创建外部类对象去访问。</li><li><!----></li></ol><p>**总结 **</p><pre><code>-  
-  
</code></pre><h3 id="练习-2" tabindex="-1"><a class="header-anchor" href="#练习-2" aria-hidden="true">#</a> <mark>练习</mark></h3><ul><li>内部类和外部类 互相调用无 权限限制</li></ul><ol><li><p>试着说一说下述访问，能否进行，怎么进行，是否受访问权限限制。</p><ol><li>成员内部类的成员方法中，去访问外部类的成员。 <ul><li>无权限限制，使用 成员名访问即可</li></ul></li><li>外部类的成员方法中，去访问成员内部类的成员。 <ul><li>无权限现在,new对象后 去访问</li></ul></li><li>外部类的静态成员方法中，去访问成员内部类的成员。 <ul><li>无权限现在,new对象后去访问</li></ul></li><li>外部其他类的成员方法中，访问成员内部类的成员。 <ul><li>有外部，和内部的权限 ，通过 new Outer().new Inner() 访问</li></ul></li><li>外部其他类的静态成员方法中，访问成员内部类的成员。 <ul><li>有外部，和内部的权限 ，通过 new Outer().new Inner() 访问</li></ul></li></ol></li><li><p>补全程序，使得可以输出三个num</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="静态内部类" tabindex="-1"><a class="header-anchor" href="#静态内部类" aria-hidden="true">#</a> 静态内部类</h2><p>​ 有时候, 使用内部类只是为了把一个类隐藏在另外一个类的内部, 并不需要内部类有外部类对象的一个引用, 如果使用static来修饰一个成员内部类, 就不会生成那个引用, 则这个内部类就属于外部类本身, 而不是属于外部类的某个对象, 这就是所谓的静态内部类.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//外部类</span>
<span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token class-name">OuterClazz</span><span class="token punctuation">{</span> 
<span class="token comment">// 静态内部类访问权限修饰符，有四个，和普通成员一样</span>
	<span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StaticInnerClazz</span><span class="token punctuation">{</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自身特点-1" tabindex="-1"><a class="header-anchor" href="#自身特点-1" aria-hidden="true">#</a> 自身特点</h3><p>依然主要从以下几个角度分析：</p><ol><li>访问权限修饰符</li><li>成员特点</li><li>继承和实现</li></ol><h4 id="访问权限修饰符-1" tabindex="-1"><a class="header-anchor" href="#访问权限修饰符-1" aria-hidden="true">#</a> 访问权限修饰符</h4><p><strong>静态内部类和成员内部类一样，有四种访问权限级别：</strong></p><ol><li>public</li><li>protected</li><li>缺省的，默认访问权限</li><li>private</li></ol><p>注：</p><ol><li>外部类可以保护静态内部类，如果想要访问一个静态内部类。首先需要外部类权限，然后还需要静态内部类权限。</li><li>既然定义内部类，仍然建议私有化。当然具体情况具体分析</li></ol><h4 id="成员特点-1" tabindex="-1"><a class="header-anchor" href="#成员特点-1" aria-hidden="true">#</a> 成员特点</h4><p>要理解静态内部类的成员有什么特点，就要像成员内部类那样，搞清楚，静态内部类到底和外部类是什么关系。<strong>在Oracle公司官网有一段文字解释静态内部类和成员内部类的区别：</strong></p><blockquote><p>Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.</p></blockquote><p>这句话直白的翻译过来就是：</p><blockquote><p>声明为static的嵌套类称为静态嵌套类，非static嵌套类才被成为内部类。</p></blockquote><p>理解这句话，关键点就在于nested和inner的区别：</p><ol><li>nested，嵌套，指的是：直接把一个类丢到另一个类中，两个类其实没太大关系。</li><li>inner，内部，指的是：某个类本身就是另一个类的一部分，在内部。</li></ol><p>这其实就已经说明白了，成员内部类和静态内部类的区别：</p><ol><li><strong><mark>成员内部类必须依赖外部类存在</mark>，创建成员内部类对象必须<mark>持有外部类对象</mark>的引用。</strong></li><li><strong>静态内部类和外部类就是<mark>独立的两个类</mark>，只不过静态内部类借用外部类来保护自己罢了。</strong></li></ol><p>相比较而言，成员内部类和外部类的关系是：心脏——身体，CPU——计算机</p><p>而静态内部类和外部类的关系是：寄居蟹——螺壳，啃老族——他的父母</p><hr><p>搞清楚上面这个问题，其实你已经学会了静态内部类。<span style="color:red;background:yellow;"><strong>它本身就该是一个独立的类，所以它和普通类的成员毫无二致！！！</strong></span></p><h4 id="继承和实现-1" tabindex="-1"><a class="header-anchor" href="#继承和实现-1" aria-hidden="true">#</a> 继承和实现</h4><p>​ 静态内部类的继承与实现和成员内部类并没有太大不同，区别在于，静态内部类只能继承一个静态内部类，而不能继承成员内部类。而且由于静态内部类的独立性很强，在外部，也可以在有权限的情况下，轻松继承一个静态内部类。</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><p>​ 静态内部类很特殊, 因为静态内部类对象和外部类对象完全独立， <span style="color:red;background:yellow;"><strong>静态内部类对象不会持有外部类对象引用</strong></span>，所以它是内部类中的异类。实际开发中，你就将它作为一个可以定义在类的内部，隐藏自身存在的一个普通类，去使用就可以了。</p><h3 id="静态内部类访问特点" tabindex="-1"><a class="header-anchor" href="#静态内部类访问特点" aria-hidden="true">#</a> 静态内部类访问特点</h3><p>在研究具体的访问前，仍先明确以下两点：</p><ol><li>内部类和外部类是&quot;好兄弟&quot;，它们之间的访问不受访问权限限制，包括私有。</li><li>静态内部类对象完全不依赖于部围类对象而存在，这意味着，互相访问，不管在哪都要创建对方对象。</li></ol><h4 id="静态内部类内部访问外部类" tabindex="-1"><a class="header-anchor" href="#静态内部类内部访问外部类" aria-hidden="true">#</a> 静态内部类内部访问外部类</h4><p>​ 不管是静态内部类中的静态方法还是成员方法，都没有外部类对象存在，需要创建对象访问。语法就直接new对象就可以了。创建好对象以后，用对象名访问即可。如果同名，有谁的引用访问的就是谁的。</p><h4 id="外部类访问静态内部类成员" tabindex="-1"><a class="header-anchor" href="#外部类访问静态内部类成员" aria-hidden="true">#</a> 外部类访问静态内部类成员</h4><p>​ 不管是静态内部类中的静态方法还是成员方法，都没有外部类对象存在，需要创建对象访问。语法就直接new对象就可以了。创建好对象以后，用对象名访问即可。如果同名，有谁的引用访问的就是谁的。</p><h4 id="外部其他类访问静态内部类成员" tabindex="-1"><a class="header-anchor" href="#外部其他类访问静态内部类成员" aria-hidden="true">#</a> 外部其他类访问静态内部类成员</h4><p>​ 主要就是考虑权限，先要有外部类权限，再要有静态内部类权限。有权限后就可以创建对象了，但是创建对象时，需要指出外部类是谁（毕竟你住人家房子里），语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">OuterClazz<span class="token punctuation">.</span>StaticInnerClazz</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClazz<span class="token punctuation">.</span>StaticInnerClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建对象后，用对象名访问成员即可。<strong>当然这个访问受权限限制。</strong></p><h4 id="静态内部类访问外部其他类成员" tabindex="-1"><a class="header-anchor" href="#静态内部类访问外部其他类成员" aria-hidden="true">#</a> 静态内部类访问外部其他类成员</h4><p>​ 创建对象访问即可，受权限控制</p><h3 id="注意事项-1" tabindex="-1"><a class="header-anchor" href="#注意事项-1" aria-hidden="true">#</a> 注意事项</h3><p>内部类也是类,也需要类加载, 静态内部类和外部类之间的类加载,它们会互相影响吗?</p><p>是不会的, 静态内部类和外补类之间本身没有依赖关系</p><p>它们的类加载,new对象,都是没有关系的</p><h3 id="练习-3" tabindex="-1"><a class="header-anchor" href="#练习-3" aria-hidden="true">#</a> 练习</h3><p>试着说一说下述访问，能否进行，怎么进行，是否受访问权限限制。</p><ol><li>静态内部类的成员方法中，去访问外部类的成员。</li><li>外部类的成员方法中，去访问静态内部类的成员。</li><li>外部类的静态成员方法中，去访问静态内部类的成员。</li><li>外部其他类的成员方法中，访问静态内部类的成员。</li><li>外部其他类的静态成员方法中，访问静态内部类的成员。</li></ol><p>总结一下，成员内部类和静态内部类的用途：</p><p>首要用途是隐藏类，当你在某个位置需要一个对象来完成需求，而你又不希望外界知道这个类时，可以用内部类, 用的时候优先用静态内部类，因为它限制比较少</p><h2 id="局部内部类" tabindex="-1"><a class="header-anchor" href="#局部内部类" aria-hidden="true">#</a> 局部内部类</h2><p>​ 局部内部类是定义在一个方法或者一个作用域里面的类，简单来说，将<mark>局部内部类看成是局部变量</mark>即可，该类的有效范围仅在作用域内部。（这意味着要创建它的对象，必须在作用域内部创建）</p><p>从语法和具体使用上看，局部内部类和成员内部类很相似，有点类似于直接把一个成员内部类放进局部位置，语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 局部位置</span>
<span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span class="token comment">// 局部位置</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自身特点-2" tabindex="-1"><a class="header-anchor" href="#自身特点-2" aria-hidden="true">#</a> 自身特点</h3><h4 id="访问权限修饰符-2" tabindex="-1"><a class="header-anchor" href="#访问权限修饰符-2" aria-hidden="true">#</a> 访问权限修饰符</h4><p>​ 局部内部类和局部变量一样，没有访问修饰权限。因为这毫无意义，大括号已经限制了它的访问范围。同样，局部内部类不能用static关键字修饰，原因和局部变量一样。</p><h4 id="成员特点-2" tabindex="-1"><a class="header-anchor" href="#成员特点-2" aria-hidden="true">#</a> 成员特点</h4><p>局部内部类的成员特点和成员内部类一模一样，不再赘述：</p><ol><li>没有静态static声明，但可以创建全局常量（不触发类加载的）</li><li>有构造方法和构造代码块。</li></ol><h4 id="继承和实现-2" tabindex="-1"><a class="header-anchor" href="#继承和实现-2" aria-hidden="true">#</a> 继承和实现</h4><p>局部内部类可以继承和实现外部的类或者接口，这是局部内部类的一个重要用途。</p><h3 id="局部内部类的访问特点" tabindex="-1"><a class="header-anchor" href="#局部内部类的访问特点" aria-hidden="true">#</a> 局部内部类的访问特点</h3><ol><li>外部类仍然把局部内部类当&quot;好兄弟&quot;，局部内部类访问外部类成员仍不受权限限制。但局部内部类的作用域已被限制死了，外部类中只有装着局部内部类的作用域内，能访问到该局部内部类。</li><li>外部其他类已经完全无法访问到局部内部类了。</li></ol><h4 id="局部内部类在外部类的成员方法中" tabindex="-1"><a class="header-anchor" href="#局部内部类在外部类的成员方法中" aria-hidden="true">#</a> 局部内部类在外部类的成员方法中</h4><p>外部类的成员方法中，是隐含自身类对象的引用的，并且这个引用编译器会自动加入到局部内部类中。也就是说， <strong>处在外部类成员方法中的局部内部类，会持有外部类对象的引用。</strong></p><p>于是：</p><ol><li>可以直接在局部内部类的成员方法中，访问外部类的成员。</li><li>如果出现同名，仍然用外部类类名.this指向外部类对象。</li><li>如果全局常量同名，就用类名点区分。</li></ol><h4 id="局部内部类在外部类的静态成员方法中" tabindex="-1"><a class="header-anchor" href="#局部内部类在外部类的静态成员方法中" aria-hidden="true">#</a> 局部内部类在外部类的静态成员方法中</h4><p>静态方法中就不存在任何对象了，其中的局部内部类也就不会持有引用了。想要访问外部类成员，就需要创建对象了。</p><h3 id="局部内部类的经典使用" tabindex="-1"><a class="header-anchor" href="#局部内部类的经典使用" aria-hidden="true">#</a> 局部内部类的经典使用</h3><p>局部内部类经常使用在以下两个场景中：</p><ol><li><p>方法需要返回一个对象，返回值类型是引用数据类型时。</p><p>方法需要返回一个对象时，可以在方法的局部位置写一个 局部内部类 继承/实现外部的类/接口，创建对象后作为返回值。这是因为方法的返回值可以是返回值类型的对象，也可以是子类对象（当返回值类型是引用数据类型时）。</p></li><li><p>方法需要传入一个对象，形参数据类型是引用数据类型时。</p><p>方法需要传入一个对象实参时，可以在调用方法的位置定义一个 局部内部类 来继承/实现外部的类/接口，创建对象后作为方法的实参传入。这是因为方法的实参可以是形参类型的对象，也可以子类对象（当返回值类型是引用数据类型时）。</p></li></ol><p>使用局部内部类的优点：</p><ol><li>绝对对外界隐藏，封装。</li><li>相比较于传统的定义类，然后创建对象，它相对更加简洁省事。</li></ol><p>缺点：</p><ol><li>这个类是一次性的。</li></ol><p>综上，假如在局部位置需要一次性的使用某个对象，可以使用局部内部类创建它，但是如果多次在不同的方法中使用，使用局部内部类就得不偿失了。</p><h3 id="注意事项-2" tabindex="-1"><a class="header-anchor" href="#注意事项-2" aria-hidden="true">#</a> 注意事项</h3><p>一. 在局部内部类的成员方法中，如果想要访问作用域内部的局部变量，那么该变量：</p><ol><li>要么直接就用final修饰，是一个局部常量。</li><li>要么就是一个事实上的常量，即只能赋值一次，相当于用final修饰它。</li></ol><p>在Java8之前版本的JDK中，如果不给能在局部内部类内部，访问的局部变量直接加上final修饰，会编译报错。</p><p>在最后，特别强调一点。后面学习的 <span style="color:red;background:yellow;"><strong>匿名内部类</strong></span> 和 <span style="color:red;background:yellow;"><strong>Lambda表达式</strong></span> 本质依然是局部内部类，这一条注意事项仍然生效。</p><p>二. 局部内部类对象作为方法的返回值, 返回值类型必须是其父类型</p><h2 id="内部类的优缺点和使用场景" tabindex="-1"><a class="header-anchor" href="#内部类的优缺点和使用场景" aria-hidden="true">#</a> 内部类的优缺点和使用场景</h2><ul><li><strong>场景一：无条件地访问外部类的所有元素（优点）</strong><ul><li><!----></li></ul></li><li><strong>场景二：隐藏类</strong><ol><li>可以用private、protected修饰内部类。</li><li>private修饰内部类、外界感受不到该类存在。</li></ol></li><li><strong>场景三：实现多继承</strong><ol><li>可以创建多个成员内部类继承外部多个类</li><li>然后创建内部类对象，实际上就是外部类继承了多个类的成员</li></ol></li><li><strong>场景四：通过匿名内部类来优化简单的接口实现/Lambda表达式更简洁</strong><ul><li><strong>重点：内部类要说使用频率 最高的肯定是匿名内部类和Lambda表达式</strong></li></ul></li></ul><p>内部类的缺点</p><ol><li><p>内部类的缺点也是显而易见，语法很复杂，在类中定义内部类也会导致类的结构变复杂，影响代码可读性。</p></li><li><p>除此之外，不合理使用内部类还可能导致内存泄漏（了解）</p><blockquote><p>持有外部类对象引用的内部类对象，如果始终被使用而没有释放：</p><!----><p>这在极端的场景下，会导致堆内存溢出，存在一定的风险。</p></blockquote></li></ol><h2 id="内部类对象" tabindex="-1"><a class="header-anchor" href="#内部类对象" aria-hidden="true">#</a> 内部类对象</h2><p><strong>学习目标</strong></p><ul><li>熟练掌握匿名内部类使用</li><li>熟练掌握lambda表达式使用</li></ul><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><p>本节内部类<mark>对象</mark>，<strong>本质</strong>上还是属于定义在别的类内部的一个类。</p><p>但区别是： 成员内部类、静态内部类和局部内部类都属于定义了一个类，后续使用还需要基于内部类创建对象。而本节中的匿名内部类和Lambda表达式都是直接通过语法创建了对象。</p><p>最后，在学习匿名内部类和Lambda表达式之前，我们还是要清楚——它们都是<mark>特殊的局部内部类</mark>。所以一旦访问方法的局部变量，该局部变量需要是一个常量(final 修饰)。</p><h3 id="匿名内部类" tabindex="-1"><a class="header-anchor" href="#匿名内部类" aria-hidden="true">#</a> 匿名内部类</h3><p>​ 我们已经使用过匿名对象了，匿名对象的含义是这个对象是没有名字，没有引用指向它。那么匿名内部类，指的就是这个内部类没有名字。当然成员内部类和静态内部类没法没有名字，所以 匿名内部类指的是&quot;没有名字的局部内部类&quot;。是一种特殊</p><h4 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h4><p>在方法等局部位置，写下列语法，即表示定义匿名内部类：</p><div class="language-JAVA line-numbers-mode" data-ext="JAVA"><pre class="language-JAVA"><code>// 局部位置
new 类名或者接口名(){
	// 某类名或接口名的子类的类体
};
// 局部位置
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释说明：</p><ol><li>new表示创建对象，表示创建语法中&quot;类名/接口名&quot;的子类对象。</li><li>这个语法结构，我们只知道这是一个子类对象，但这个子类到底叫啥，不知道，所以它是一个匿名类。当然匿名内部类更准确的说法，应该叫匿名内部类对象。</li><li>匿名内部类的本质是，一个继承了类或者实现了接口的匿名子类对象。</li></ol><h4 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h4><p>匿名内部类是特殊的局部内部类，它的成员特征、访问特征和局部内部类没有区别。这里不再赘述。</p><p>这里我们直接说明一下，匿名内部类对象的两种使用方式：</p><ul><li>可以直接在后面调用方法，访问它的成员（当一个匿名对象使用） <ol><li>优点是：可以访问子类独有的成员。方便快捷，不需要用引用接收再去使用</li><li>缺点是：一次性，仅能用一次</li></ol></li><li>可以用（父）引用接收对象，然后再用引用访问成员 <ol><li>优点是：可以用多次</li><li>缺点是：不能访问子类独有成员（被父类引用限制了访问范围，无法强转，因为子类已经匿名了)</li></ol></li></ul><p>综上，两种使用方式场景不同。如果有多次使用需求，就需要父引用接收；反之如果仅用一次，或者需要访问子类独有成员，就必须直接使用，不能用引用接收。</p><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h4><p>​ 匿名内部类实际上就是更简单的局部内部类（直接获取了对象），所以局部内部类的使用场景，可以直接套用过来。</p><p>匿名内部类经常使用在以下两个场景中：</p><ol><li><p>方法需要返回一个对象，返回值类型是引用数据类型时。</p><p>方法需要返回一个对象时，可以在方法的局部位置写一个 基于X类或X接口的匿名内部类对象 ，然后直接作为返回值返回给外界。</p></li><li><p>方法需要传入一个对象，形参数据类型是引用数据类型时。</p><p>方法需要传入一个对象实参时，可以在调用方法的实参位置填入一个 基于X类或X接口的匿名内部类对象，就将它作为一个实参传给方法使用。</p></li></ol><p>使用匿名内部类的优点：</p><ol><li>绝对对外界隐藏，封装。</li><li>比起局部内部类，它更方便简洁了。所以实际开发中，匿名内部类基本取代了局部内部类的作用。</li></ol><p>缺点：</p><ol><li>这个对象是一次性的。</li></ol><p>总之，酌情使用匿名内部类对象，可以简化代码书写，方便省事。但不要为了使用而使用，假如存在多个场景都需要一个子类对象，那还是直接创建一个子类出来好了。</p><h4 id="练习-4" tabindex="-1"><a class="header-anchor" href="#练习-4" aria-hidden="true">#</a> 练习</h4><p>不修改main方法和接口Inter的前提下，补齐Outer类代码，要求在控制台输出HelloWorld</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name">Outer</span><span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Inter</span> <span class="token punctuation">{</span>
 <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>几种实现方式:</p><ul><li>手写类实现接口</li><li>局部内部类</li><li>匿名内部类</li><li>lambda表达式</li></ul><h3 id="lambda表达式" tabindex="-1"><a class="header-anchor" href="#lambda表达式" aria-hidden="true">#</a> lambda表达式</h3><p>Lambda 表达式是 JDK8 的一个新特性，可以取代接口的匿名内部类，写出更优雅的Java 代码。</p><ol><li>Lambda表达式仍然是局部内部类，是特殊的局部内部类，仍然定义在局部位置。而且局部内部类的注意事项，也一样存在。</li><li>Lambda表达式在取代匿名内部类时，不是全部都取代，而是取代<strong>接口</strong>的匿名内部类，而类的匿名内部类Lambda表达式是不能取代的。</li><li>Lambda表达式是匿名内部类的更进一步， Lambda表达式得到的也不是一个类，而是一个对象，并且是接口的子类对象。</li></ol><h4 id="使用前提" tabindex="-1"><a class="header-anchor" href="#使用前提" aria-hidden="true">#</a> 使用前提</h4><p>Lambda表达式虽然说是取代<mark>接口的匿名内部类</mark>，但也不是什么接口都能用Lambda表达式创建子类对象。</p><p>Lambda表达式要求的接口中，必须<mark>有且仅有一个必须要实现的抽象方法</mark>。这种接口在Java中，被称之为&quot;功能接口&quot;。功能接口在语法上，可以使用注解==@FunctionalInterface<mark>标记在接口头上，用于</mark>检测一个接口是否是功能接口==。</p><p>例如：</p><p>注解@FunctionalInterface</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IA</span><span class="token punctuation">{</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中<code>IA</code>接口就是一个功能接口，注解就不会编译报错，反之就会编译报错。这有点类似于@Override注解对方法重写的检验。</p><hr><p>看完上述关于功能接口的语法定义，思考两个问题：</p><ol><li>功能接口中只能有一个方法吗？</li><li>功能接口中只能有一个抽象方法吗？</li></ol><p>答：</p><ol><li><p>不是，Java8中的默认方法和静态方法不需要子类实现，功能接口中可以允许有它们存在。</p></li><li><p>不是，有极个别比较特殊的抽象方法，可以不需要子类实现。</p><p>注：Object类是Java每一个类的父类，所以Object类当中的方法实现就可以作为接口抽象方法的实现。比如：</p><p>功能接口不仅有一个抽象方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IA</span><span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>接口IA仍然是一个功能方法，因为抽象方法boolean equals(Object obj);可以直接使用Object类中的实现，无需子类实现。</p><p>所以，再强调一下，<strong>功能接口指的是，有且仅有一个必须要子类实现的抽象方法的接口。</strong></p><h4 id="基本使用-1" tabindex="-1"><a class="header-anchor" href="#基本使用-1" aria-hidden="true">#</a> 基本使用</h4><p>​ 功能接口准备完毕后，就可以写Lambda表达式的语法，表示创建功能接口的子类对象了。当然Lambda表达式是特殊的局部内部类，仍然要写在局部位置。</p><p>它的语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
<span class="token comment">// 方法体	</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释一下：</p><ol><li>(形参列表)表示功能接口中，必须要重写的抽象方法的形参列表。</li><li>-&gt;由一个英文横杠 + 英文大于号字符组成，它是Lambda表达式的运算符，读作<mark>goes to</mark>。</li><li>{ //方法体 }表示功能接口中，必须要重写的抽象方法的，方法体实现。</li></ol><p>其实，看完这个Lambda表达式的语法定义，就已经能够解释为什么Lambda表达式，要求接口有且只有一个必须要实现的抽象方法了。因为语法中仅有一套形参列表和方法体，只能重写一个方法。</p><p>而且，这个语法写出来，很明显Lambda表达式只能重写父接口中的抽象方法，是不能自己新增成员的！</p><hr><p>在方法等局部位置，写上述语法后，肯定会报错。原因在于Java是强类型语言，任何变量都有它的数据类型，而直接写Lambda表达式语言，编译器是无从得知它的数据类型的——这个Lambda表达式创建了接口的子类对象，到底是哪个接口的子类对象呢？</p><p>所以我们需要帮助编译器，明确Lambda表达式所表示的对象的类型，这个过程称之为 &quot;Lambda表达式的类型推断&quot;。</p><p>怎么推断呢？在这个推断过程中，需要给编译器提供额外的信息，告诉它Lambda表达式是哪个接口的子类对象。总得来说，常见和常用的有以下三种方式：</p><ol><li><p>直接用父接口引用接收。由于Lambda表达式表示的子类对象并没有自己独有的成员，所以直接用父类引用接收完全不会有任何问题。</p></li><li><p>不用引用接收，但是要直接告诉编译器Lambda表达式是哪个接口的子类对象，语法上有点像强转（但不是）。</p><p>语法：</p><p>((父接口的名字)Lambda表达式).方法名(实参)</p><p>这种方式有点类似于匿名对象，所以必须直接调用方法，不然会编译语法报错。</p></li><li><p>借助方法完成类型推断。</p><ol><li>可以借助方法的返回值数据类型完成类型推断，因为方法的返回值编译器已经知道该返回什么对象。</li><li>可以借助方法的形参的数据类型完成类型推断，因为方法的实参编译器已经知道该传入什么对象。</li></ol></li></ol><h4 id="进阶使用和简化" tabindex="-1"><a class="header-anchor" href="#进阶使用和简化" aria-hidden="true">#</a> 进阶使用和简化</h4><p>为了方便语法练习，这里给出六个功能接口：</p><p>功能接口案例</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//无返回值无参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">INoReturnNoParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//无返回值有一个参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">INoReturnOneParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//无返回值两个参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">INoReturnTwoParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//有返回值无参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IHasReturnNoParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//有返回值一个参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IHasReturnOneParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//有返回值两个参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IHasReturnTwoParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们基于上述功能接口，讲解一下Lambda表达式的进阶使用， 主要就是格式的简化</p><p>逐个部分简化：</p><ol><li><p>(形参列表)能不能简化呢？是可以的，因为功能接口中有且仅有一个必须要实现的抽象方法，那么：</p><ol><li><mark>形参的数据类型是可以省略的</mark>，因为方法已经固定死了，形参一定是那些，不需要写出来。但形参的名字是不可省略的（因为要在方法体中使用）</li><li>特殊情况下： <ul><li>如果形参列表中的形参只有一个，那么()小括号，也是可以省略的。</li><li>但是如果形参为空，()小括号是不可以省略的。</li></ul></li></ol></li><li><p>{ //方法体 }方法体能不能简化呢？当然是可以的：</p><ol><li>如果方法重写的方法体只有一条语句的话，那么可以省略大括号。（类似于if/for省略大括号）</li><li>特殊的，如果只有一条语句且这条语句是返回值语句，那么大括号和return可以一起省略。</li></ol></li><li><p>实际上在多数情况下，都不太可能一句话把方法体写完。多数情况下，Lambda表达式的抽象方法实现都会很复杂，那这样Lambda表达式就会写的很复杂，这就很难受了。而Lambda表达式，本质上就是重写了一个抽象方法的子类对象，所以Java允许Lambda表达式的抽象方法的实现可以直接指向一个已经存在的方法，而不是自己书写实现。这种语法在Java中称之为&quot;方法引用&quot;！</p><h4 id="方法引用" tabindex="-1"><a class="header-anchor" href="#方法引用" aria-hidden="true">#</a> 方法引用</h4><p>Lambda表达式的主体只有1条语句时, 程序不仅可以省略主体的大括号, 还可以通过==英文双冒号::==的语法来引用方法, 进一步简化Lambda表达式的书写.</p><p>什么样的方法，能够作为<mark>方法引用</mark>指向的功能接口中抽象方法的实现？只看三点：</p><ol><li><mark>返回值类型必须一致。</mark></li><li>(方法签名method signature一致)形参列表中的<mark>数量，类型，位置</mark>必须都对应上，形参名字无所谓。</li><li>方法的名字无所谓。</li></ol><p><strong>Lambda表达式支持的方法引用</strong></p><table><thead><tr><th>种类</th><th>Lambda表达式示例</th><th>对应的引用示例</th><th>解释说明</th></tr></thead><tbody><tr><td>类名引用静态方法</td><td>(x, y, ...) -&gt; 类名.静态方法名(x, y, ...)</td><td>类名::静态方法名</td><td>功能接口中被实现方法的全部参数传给该类静态方法作为参数</td></tr><tr><td>对象名引用成员方法</td><td>(x, y, ...) -&gt; 对象名.成员方法名(x, y, ...)</td><td>对象名::成员方法名</td><td>功能接口中被实现方法的全部参数传给该成员方法作为参数</td></tr><tr><td><mark>类名引用成员方法(<strong>特殊</strong>)</mark></td><td><mark>(x, y, ...) -&gt; **对象名x.**成员方法名(y, ...)</mark></td><td>类名::成员方法名(<strong>不是静态方法</strong>)</td><td><mark>功能接口中被实现方法的第一个参数作为调用者, 后面的参数传给该成员方法作为参数</mark></td></tr><tr><td>构造方法引用</td><td>(x, y, ...) -&gt; new 类名(x, y, ...)</td><td>类名::new</td><td>功能接口中被实现方法的全部参数传给该构造器作为参数</td></tr></tbody></table></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">/*
Lambda表达式的主体只有1条语句时, 程序不仅可以省略主体的大括号,
还可以通过英文双冒号::的语法来引用方法, 进一步简化Lambda表达式的书写.

什么样的方法，能够作为方法引用指向的功能接口中抽象方法的实现？
只看三点：
1. 返回值类型必须一致。
2. (方法签名method signature一致)形参列表中的数量，类型，位置必须都对应上，
形参名字无所谓。
3. 方法的名字无所谓。
 */</span>
<span class="token comment">/*
1.静态方法引用
2.对象名引用成员方法
3.类名引用成员方法
4.构造方法引用
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 静态方法引用</span>
        <span class="token comment">// lambda写法</span>
        <span class="token class-name">IA</span> ia2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ia2<span class="token punctuation">.</span><span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">IA</span> ia <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ia<span class="token punctuation">.</span><span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 方法引用</span>
        <span class="token class-name">IA</span> ia1 <span class="token operator">=</span> <span class="token class-name">A</span><span class="token operator">::</span><span class="token function">func1</span><span class="token punctuation">;</span>
        ia1<span class="token punctuation">.</span><span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token comment">// 对象名引用成员方法</span>
        <span class="token comment">// lambda</span>
        <span class="token class-name">IC</span> ic2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        ic2<span class="token punctuation">.</span><span class="token function">testC</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">IC</span> ic <span class="token operator">=</span>  a <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ic<span class="token punctuation">.</span><span class="token function">testC</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 方法引用</span>
        <span class="token class-name">IC</span> ic1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">::</span><span class="token function">func2</span><span class="token punctuation">;</span>
        ic1<span class="token punctuation">.</span><span class="token function">testC</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token comment">//IB ib = s -&gt; System.out.println(s);</span>
        <span class="token comment">//ib.testB(&quot;aaa&quot;);</span>

        <span class="token comment">// 可以指向源码中的方法或者第三方工具的方法</span>
        <span class="token class-name">IB</span> ib <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">;</span>
        ib<span class="token punctuation">.</span><span class="token function">testB</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>



        <span class="token comment">// &quot;abcdef&quot;, 希望对字符串进行截取&quot;bc&quot;</span>
        <span class="token comment">// 主要使用String类中的成员方法</span>
        <span class="token comment">// subString( int start,int end)  [start,end)</span>
        <span class="token comment">//String s = &quot;abcdef&quot;;</span>
        <span class="token comment">//String substring = s.substring(1, 3);</span>
        <span class="token comment">//System.out.println(&quot;substring = &quot; + substring);</span>


        <span class="token comment">// 类名引用成员方法</span>
        <span class="token comment">// lambda</span>
        <span class="token class-name">ID</span> id <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> str <span class="token operator">=</span> id<span class="token punctuation">.</span><span class="token function">testD</span><span class="token punctuation">(</span><span class="token string">&quot;abcdef&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;str = &quot;</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token class-name">ID</span> id2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">substring</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> str2 <span class="token operator">=</span> id2<span class="token punctuation">.</span><span class="token function">testD</span><span class="token punctuation">(</span><span class="token string">&quot;abcdef&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;str2 = &quot;</span> <span class="token operator">+</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token comment">// 4.构造方法引用</span>
        <span class="token comment">// lambda表达式</span>
        <span class="token comment">// 有参构造</span>
        <span class="token class-name">IE</span> ie <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Dog</span> dog <span class="token operator">=</span> ie<span class="token punctuation">.</span><span class="token function">getDog</span><span class="token punctuation">(</span><span class="token string">&quot;小黑&quot;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 无参构造</span>
        <span class="token class-name">IG</span> ig <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Dog</span> dog1 <span class="token operator">=</span> ig<span class="token punctuation">.</span><span class="token function">getDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 方法引用</span>
        <span class="token class-name">IE</span> ie2 <span class="token operator">=</span> <span class="token class-name">Dog</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span>
        <span class="token class-name">Dog</span> dog2 <span class="token operator">=</span> ie2<span class="token punctuation">.</span><span class="token function">getDog</span><span class="token punctuation">(</span><span class="token string">&quot;小花&quot;</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog2<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">IG</span> ig2 <span class="token operator">=</span> <span class="token class-name">Dog</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span>
        <span class="token class-name">Dog</span> dog3 <span class="token operator">=</span> ig2<span class="token punctuation">.</span><span class="token function">getDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog3<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IA</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token comment">// 定义一个静态方法 作为IA接口中的testA方法的实现</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;IA接口中的testA方法的实现&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IB</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">testB</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IC</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">testC</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">ID</span><span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">testD</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IE</span><span class="token punctuation">{</span>
    <span class="token class-name">Dog</span> <span class="token function">getDog</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IG</span><span class="token punctuation">{</span>
    <span class="token class-name">Dog</span> <span class="token function">getDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">{</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="注意事项-3" tabindex="-1"><a class="header-anchor" href="#注意事项-3" aria-hidden="true">#</a> 注意事项</h4><ol><li>方法引用所指向的实现方法, 只要是已经存在的就可以, 可以自己写, 可以用源码的方法或者第三方工具类的方法</li><li>Lambda表达式是特殊的局部内部类，所以它访问方法的局部变量，该变量必须是final的（实际常量）。</li><li>除此之外，局部内部类，匿名内部类它们都有自己独立的作用域，能够自定义自己的成员。 <span style="color:red;background:yellow;"><strong>但是Lambda表达式没有自身独立的作用域，不能自定义成员，和所在的方法共用同一个作用域。</strong></span></li></ol><h4 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h4><ol><li><p>优点：</p><ol><li><p><strong>极大得简化了代码，使代码变得更加优雅。</strong></p></li><li><p>函数式编程的代表，可能是未来高端的编程趋势</p><ul><li>Lambda表达式在Stream API中，配合集合类去使用，代码非常优雅和简洁，并且高效，实际开发中十分常用。</li></ul><p>Stream API代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>list<span class="token punctuation">.</span>
  <span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
	<span class="token function">filter</span><span class="token punctuation">(</span>stu <span class="token operator">-&gt;</span> stu<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
	<span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
	<span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：该Stream API完成，将学生对象集合中的，所有大于等于18岁的学生的成绩输出的工作。</p></li></ol></li><li><p>缺点：</p><ol><li>过于简单的Lambda表达式，显然可读性很低。</li><li>过于简洁也意味着不容易Debug。</li><li>语法难度不低，熟练使用需要时间锻炼。</li></ol></li></ol></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/LSauce/JavaFarms/edit/main/src/Java/SE/6_面向对象设计.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a aria-label="05.面向对象三大特征" class="vp-link nav-link prev nav-link prev" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>05.面向对象三大特征</div></a><a aria-label="08.补充其他常用类" class="vp-link nav-link next nav-link next" href="/Java/SE/8_%E8%A1%A5%E5%85%85%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%B1%BB.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">08.补充其他常用类<span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper"><!----><div class="vp-copyright">Copyright © 2023 JavaFarmer</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-58d2c58f.js" defer></script>
  </body>
</html>
