<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.67" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://jf.kiroe.cn/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html"><meta property="og:site_name" content="JavaFarms"><meta property="og:title" content="05.面向对象三大特征"><meta property="og:description" content="封装 ​		封装就是面向对象的核心思想，将对象的属性和行为封装起来，不需要让外界知道具体的实现细节。例如，用户使用手机，只需要在屏幕上滑动点击就可以了，无须知道手机内部时如何工作的。 继承 ​	继承主要描述的是类与类之间的关系，通过继承，可以在无需编写原有类的情况下，对原有类的功能进行扩展。例如，有一个汽车类，该类中描述了汽车的普通属性和功能。汽车有很..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="JavaFarmer"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"05.面向对象三大特征","image":[""],"dateModified":null,"author":[{"@type":"Person","name":"JavaFarmer","url":"https://jf.kiroe.cn"}]}</script><title>05.面向对象三大特征 | JavaFarms</title><meta name="description" content="封装 ​		封装就是面向对象的核心思想，将对象的属性和行为封装起来，不需要让外界知道具体的实现细节。例如，用户使用手机，只需要在屏幕上滑动点击就可以了，无须知道手机内部时如何工作的。 继承 ​	继承主要描述的是类与类之间的关系，通过继承，可以在无需编写原有类的情况下，对原有类的功能进行扩展。例如，有一个汽车类，该类中描述了汽车的普通属性和功能。汽车有很...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-b8845d42.css" as="style"><link rel="stylesheet" href="/assets/style-b8845d42.css">
    <link rel="modulepreload" href="/assets/app-58d2c58f.js"><link rel="modulepreload" href="/assets/5_面向对象三大特征.html-3ac8dfef.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js"><link rel="modulepreload" href="/assets/5_面向对象三大特征.html-c963b7db.js"><link rel="prefetch" href="/assets/index.html-8b0da2f8.js" as="script"><link rel="prefetch" href="/assets/slides.html-06c60ee3.js" as="script"><link rel="prefetch" href="/assets/111.二叉树的最小深度.html-c3759c57.js" as="script"><link rel="prefetch" href="/assets/index.html-12824d2e.js" as="script"><link rel="prefetch" href="/assets/index.html-bf2b997f.js" as="script"><link rel="prefetch" href="/assets/0_IDEA安装与设置.html-cc1b696c.js" as="script"><link rel="prefetch" href="/assets/0_Java基本介绍.html-bbfcbd83.js" as="script"><link rel="prefetch" href="/assets/0_git使用.html-b515bfa9.js" as="script"><link rel="prefetch" href="/assets/0_常用软件.html-c564764e.js" as="script"><link rel="prefetch" href="/assets/10_异常.html-452e35b9.js" as="script"><link rel="prefetch" href="/assets/11_File.html-062f419a.js" as="script"><link rel="prefetch" href="/assets/12_IO.html-2fb86795.js" as="script"><link rel="prefetch" href="/assets/14_网络编程.html-6e6c8f8a.js" as="script"><link rel="prefetch" href="/assets/15_反射.html-825dc706.js" as="script"><link rel="prefetch" href="/assets/16_注解.html-4ede9ad6.js" as="script"><link rel="prefetch" href="/assets/17_GC.html-4e507034.js" as="script"><link rel="prefetch" href="/assets/2_方法.html-65036dcd.js" as="script"><link rel="prefetch" href="/assets/3_补充递归.html-3fafbb08.js" as="script"><link rel="prefetch" href="/assets/4_面向对象基础.html-3d8c71d3.js" as="script"><link rel="prefetch" href="/assets/6_面向对象设计.html-180e4923.js" as="script"><link rel="prefetch" href="/assets/8_补充其他常用类.html-a222f1c2.js" as="script"><link rel="prefetch" href="/assets/9_String.html-3f8b08a6.js" as="script"><link rel="prefetch" href="/assets/index.html-e90b828d.js" as="script"><link rel="prefetch" href="/assets/index.html-b5369b7a.js" as="script"><link rel="prefetch" href="/assets/baz.html-6a4a3825.js" as="script"><link rel="prefetch" href="/assets/index.html-5646379c.js" as="script"><link rel="prefetch" href="/assets/ray.html-75298494.js" as="script"><link rel="prefetch" href="/assets/git协同上传文章手册.html-75ac4af0.js" as="script"><link rel="prefetch" href="/assets/分支测试.html-86de3404.js" as="script"><link rel="prefetch" href="/assets/404.html-23d166f3.js" as="script"><link rel="prefetch" href="/assets/index.html-900244cb.js" as="script"><link rel="prefetch" href="/assets/index.html-2dc067e6.js" as="script"><link rel="prefetch" href="/assets/index.html-39efe404.js" as="script"><link rel="prefetch" href="/assets/slides.html-cb3e087c.js" as="script"><link rel="prefetch" href="/assets/111.二叉树的最小深度.html-2b994ddf.js" as="script"><link rel="prefetch" href="/assets/index.html-0d70e827.js" as="script"><link rel="prefetch" href="/assets/index.html-750c711d.js" as="script"><link rel="prefetch" href="/assets/0_IDEA安装与设置.html-43979e5e.js" as="script"><link rel="prefetch" href="/assets/0_Java基本介绍.html-765494f9.js" as="script"><link rel="prefetch" href="/assets/0_git使用.html-4ddfcabe.js" as="script"><link rel="prefetch" href="/assets/0_常用软件.html-895d00b8.js" as="script"><link rel="prefetch" href="/assets/10_异常.html-b79ac0bb.js" as="script"><link rel="prefetch" href="/assets/11_File.html-a3e1f2d7.js" as="script"><link rel="prefetch" href="/assets/12_IO.html-4fd719e6.js" as="script"><link rel="prefetch" href="/assets/14_网络编程.html-7d72c16f.js" as="script"><link rel="prefetch" href="/assets/15_反射.html-19832de1.js" as="script"><link rel="prefetch" href="/assets/16_注解.html-22ee790e.js" as="script"><link rel="prefetch" href="/assets/17_GC.html-7ac18219.js" as="script"><link rel="prefetch" href="/assets/2_方法.html-8d7f1dce.js" as="script"><link rel="prefetch" href="/assets/3_补充递归.html-2630c40b.js" as="script"><link rel="prefetch" href="/assets/4_面向对象基础.html-42d451f2.js" as="script"><link rel="prefetch" href="/assets/6_面向对象设计.html-ecedbbaa.js" as="script"><link rel="prefetch" href="/assets/8_补充其他常用类.html-90165cb2.js" as="script"><link rel="prefetch" href="/assets/9_String.html-f57dcd61.js" as="script"><link rel="prefetch" href="/assets/index.html-315ed14e.js" as="script"><link rel="prefetch" href="/assets/index.html-5fa301e3.js" as="script"><link rel="prefetch" href="/assets/baz.html-a09199b0.js" as="script"><link rel="prefetch" href="/assets/index.html-de2c4154.js" as="script"><link rel="prefetch" href="/assets/ray.html-5b804ad4.js" as="script"><link rel="prefetch" href="/assets/git协同上传文章手册.html-2d382f50.js" as="script"><link rel="prefetch" href="/assets/分支测试.html-df7f5b8e.js" as="script"><link rel="prefetch" href="/assets/404.html-c8dbd472.js" as="script"><link rel="prefetch" href="/assets/index.html-8f3aa0fc.js" as="script"><link rel="prefetch" href="/assets/index.html-e03f8b40.js" as="script"><link rel="prefetch" href="/assets/giscus-0b7adcf8.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-1464cdb9.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/"><img class="vp-nav-logo" src="/logo.svg" alt="JavaFarms"><!----><span class="vp-site-name hide-in-pad">JavaFarms</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="JavaFarms主页" class="vp-link nav-link nav-link" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>JavaFarms主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="Java"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>Java</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>SE</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="JavaSE基础" class="vp-link nav-link active nav-link active" href="/Java/SE/"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>JavaSE基础<!----></a></li><li class="dropdown-subitem"><a aria-label="Java语法" class="vp-link nav-link nav-link" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html"><span class="font-icon icon fa-fw fa-sm fas fa-ellipsis" style=""></span>Java语法<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a aria-label="算法" class="vp-link nav-link nav-link" href="/Algorithm/"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>算法<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="文章上传手册" class="vp-link nav-link nav-link" href="/guide/manual/git%E5%8D%8F%E5%90%8C%E4%B8%8A%E4%BC%A0%E6%96%87%E7%AB%A0%E6%89%8B%E5%86%8C.html"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>文章上传手册<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/LSauce/JavaFarms" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><!--[--><a aria-label="JavaFarms主页" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>JavaFarms主页<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">Java</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><span class="vp-sidebar-title">JavaSE基础</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="0.git使用" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/0_git%E4%BD%BF%E7%94%A8.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>0.git使用<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="0.IDEA安装与设置" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/0_IDEA%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>0.IDEA安装与设置<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="0.Java基本介绍" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/0_Java%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>0.Java基本介绍<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="0.常用软件" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/0_%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>0.常用软件<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="02.方法" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/2_%E6%96%B9%E6%B3%95.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>02.方法<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="03.补充递归" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/3_%E8%A1%A5%E5%85%85%E9%80%92%E5%BD%92.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>03.补充递归<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="04.面向对象基础" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/4_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>04.面向对象基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="05.面向对象三大特征" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>05.面向对象三大特征<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="封装" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#封装"><!---->封装<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="继承" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#继承"><!---->继承<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="多态" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#多态"><!---->多态<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="概述" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#概述-1"><!---->概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="封装实现步骤" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#封装实现步骤"><!---->封装实现步骤<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="封装练习" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#封装练习"><!---->封装练习<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="注意事项" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#注意事项"><!---->注意事项<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="引例" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#引例"><!---->引例<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="语法定义" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#语法定义"><!---->语法定义<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="继承中两个类的关系" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#继承中两个类的关系"><!---->继承中两个类的关系<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="两个类的命名" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#两个类的命名"><!---->两个类的命名<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="从属关系(重点)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#从属关系-重点"><!---->从属关系(重点)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="引用数据类型的类型转换(重点)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#引用数据类型的类型转换-重点"><!---->引用数据类型的类型转换(重点)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="引用数据类型转换的前提" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#引用数据类型转换的前提"><!---->引用数据类型转换的前提<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="转换的是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#转换的是什么"><!---->转换的是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="引用数据类型转换分类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#引用数据类型转换分类"><!---->引用数据类型转换分类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="继承的优缺点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#继承的优缺点"><!---->继承的优缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="继承的层次(重点)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#继承的层次-重点"><!---->继承的层次(重点)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="单继承" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#单继承"><!---->单继承<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="继承层级" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#继承层级"><!---->继承层级<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="protected访问权限" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#protected访问权限"><!---->protected访问权限<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="怎么理解不同包子类能够访问" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#怎么理解不同包子类能够访问"><!---->怎么理解不同包子类能够访问<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="结论" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#结论"><!---->结论<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="为什么设置protected访问权限" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#为什么设置protected访问权限"><!---->为什么设置protected访问权限<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="经典案例" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#经典案例"><!---->经典案例<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="继承的限制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#继承的限制"><!---->继承的限制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="子类对象的初始化(重点)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#子类对象的初始化-重点"><!---->子类对象的初始化(重点)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="子类对象初始化流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#子类对象初始化流程"><!---->子类对象初始化流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="隐式子类对象初始化" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#隐式子类对象初始化"><!---->隐式子类对象初始化<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="显示子类对象初始化" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#显示子类对象初始化"><!---->显示子类对象初始化<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="super关键字" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#super关键字"><!---->super关键字<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="练习" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#练习"><!---->练习<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="总结" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#总结"><!---->总结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="继承中的属性隐藏" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#继承中的属性隐藏"><!---->继承中的属性隐藏<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="引例" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#引例-1"><!---->引例<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="对象名.成员变量的访问机制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#对象名-成员变量的访问机制"><!---->对象名.成员变量的访问机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="属性隐藏" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#属性隐藏"><!---->属性隐藏<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="继承中的方法覆盖" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#继承中的方法覆盖"><!---->继承中的方法覆盖<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="引例" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#引例-2"><!---->引例<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="对象名.成员方法的访问机制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#对象名-成员方法的访问机制"><!---->对象名.成员方法的访问机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="方法的覆盖/重写" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#方法的覆盖-重写"><!---->方法的覆盖/重写<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="final关键字" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#final关键字"><!---->final关键字<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="final修饰类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#final修饰类"><!---->final修饰类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="final修饰方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#final修饰方法"><!---->final修饰方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="final修饰变量" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#final修饰变量"><!---->final修饰变量<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="练习" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#练习-2"><!---->练习<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="概述" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#概述-2"><!---->概述<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="基本概念" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#基本概念"><!---->基本概念<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="多态的发生条件" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#多态的发生条件"><!---->多态的发生条件<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="不能发生多态的场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#不能发生多态的场景"><!---->不能发生多态的场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="多态的访问特征" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#多态的访问特征"><!---->多态的访问特征<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="成员变量" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#成员变量"><!---->成员变量<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="成员方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#成员方法"><!---->成员方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="多态的优缺点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#多态的优缺点"><!---->多态的优缺点<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="优点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#优点"><!---->优点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="缺点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#缺点"><!---->缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="引用数据类型的强制类型转换" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#引用数据类型的强制类型转换"><!---->引用数据类型的强制类型转换<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="前提" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#前提"><!---->前提<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="instanceof关键字" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#instanceof关键字"><!---->instanceof关键字<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="总结" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#总结-3"><!---->总结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="多态练习" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/Java/SE/5_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html#多态练习"><!---->多态练习<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a aria-label="06.面向对象设计" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>06.面向对象设计<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="08.补充其他常用类" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/8_%E8%A1%A5%E5%85%85%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%B1%BB.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>08.补充其他常用类<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="09.String" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/9_String.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>09.String<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="10.异常" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/10_%E5%BC%82%E5%B8%B8.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>10.异常<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="11.File" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/11_File.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>11.File<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="12.IO" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/12_IO.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>12.IO<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="14.网络编程" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/14_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>14.网络编程<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="15.反射" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/15_%E5%8F%8D%E5%B0%84.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>15.反射<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="16.注解" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/16_%E6%B3%A8%E8%A7%A3.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>16.注解<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="17.GC" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SE/17_GC.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>17.GC<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul></section></li><li><!--[--><a aria-label="幻灯片页" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/slides.html"><span class="font-icon icon fa-fw fa-sm fas fa-person-chalkboard" style=""></span>幻灯片页<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span><span class="vp-sidebar-title">指南</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><span class="vp-sidebar-title">算法</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>05.面向对象三大特征</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://jf.kiroe.cn" target="_blank" rel="noopener noreferrer">JavaFarmer</a></span><span property="author" content="JavaFarmer"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 63 分钟</span><meta property="timeRequired" content="PT63M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category1" role>JavaSE</span><!--]--><meta property="articleSection" content="JavaSE"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#封装">封装</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#继承">继承</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#多态">多态</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#概述-1">概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#封装实现步骤">封装实现步骤</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#封装练习">封装练习</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#注意事项">注意事项</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#引例">引例</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#语法定义">语法定义</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#继承中两个类的关系">继承中两个类的关系</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#两个类的命名">两个类的命名</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#从属关系-重点">从属关系(重点)</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#引用数据类型的类型转换-重点">引用数据类型的类型转换(重点)</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#引用数据类型转换的前提">引用数据类型转换的前提</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#转换的是什么">转换的是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#引用数据类型转换分类">引用数据类型转换分类</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#继承的优缺点">继承的优缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#继承的层次-重点">继承的层次(重点)</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#单继承">单继承</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#继承层级">继承层级</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#protected访问权限">protected访问权限</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#怎么理解不同包子类能够访问">怎么理解不同包子类能够访问</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#结论">结论</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#为什么设置protected访问权限">为什么设置protected访问权限</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#经典案例">经典案例</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#继承的限制">继承的限制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#子类对象的初始化-重点">子类对象的初始化(重点)</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#子类对象初始化流程">子类对象初始化流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#隐式子类对象初始化">隐式子类对象初始化</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#显示子类对象初始化">显示子类对象初始化</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#super关键字">super关键字</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#练习">练习</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#总结">总结</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#继承中的属性隐藏">继承中的属性隐藏</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#引例-1">引例</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#对象名-成员变量的访问机制">对象名.成员变量的访问机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#属性隐藏">属性隐藏</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#继承中的方法覆盖">继承中的方法覆盖</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#引例-2">引例</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#对象名-成员方法的访问机制">对象名.成员方法的访问机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#方法的覆盖-重写">方法的覆盖/重写</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#final关键字">final关键字</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#final修饰类">final修饰类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#final修饰方法">final修饰方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#final修饰变量">final修饰变量</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#练习-2">练习</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#概述-2">概述</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#基本概念">基本概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#多态的发生条件">多态的发生条件</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#不能发生多态的场景">不能发生多态的场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#多态的访问特征">多态的访问特征</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#成员变量">成员变量</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#成员方法">成员方法</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#多态的优缺点">多态的优缺点</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#优点">优点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#缺点">缺点</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#引用数据类型的强制类型转换">引用数据类型的强制类型转换</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#前提">前提</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#instanceof关键字">instanceof关键字</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/#总结-3">总结</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/#多态练习">多态练习</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h1><h2 id="封装" tabindex="-1"><a class="header-anchor" href="#封装" aria-hidden="true">#</a> 封装</h2><p>​ 封装就是面向对象的核心思想，将对象的属性和行为封装起来，不需要让外界知道具体的实现细节。例如，用户使用手机，只需要在屏幕上滑动点击就可以了，无须知道手机内部时如何工作的。</p><h2 id="继承" tabindex="-1"><a class="header-anchor" href="#继承" aria-hidden="true">#</a> 继承</h2><p>​ 继承主要描述的是类与类之间的关系，通过继承，可以在无需编写原有类的情况下，对原有类的功能进行扩展。例如，有一个汽车类，该类中描述了汽车的普通属性和功能。汽车有很多类型，轿车，卡车，越野，SUV等，那么在一个轿车类中，不仅应该包含汽车的属性和功能，还应该增加轿车独有的属性和功能，这时，可以让桥车继承汽车类，在轿车类中添加轿车特有的功能和属性就可以了。继承不仅增强了代码的复用性，提高了开发效率，还为程序的维护补充提供了便利。</p><h2 id="多态" tabindex="-1"><a class="header-anchor" href="#多态" aria-hidden="true">#</a> 多态</h2><p>​ 多态指的是在一个类中定义的属性和功能被其他类继承后，会把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一个方法所呈现的多种不同行为特征。例如，当我们说请坐的时候，日本人听到可能会跪坐，中国人听到可能会盘腿而坐，不同的对象可能呈现不同的行为。</p><h1 id="封装-1" tabindex="-1"><a class="header-anchor" href="#封装-1" aria-hidden="true">#</a> 封装</h1><p>学习目标:</p><ul><li>掌握封装的概念与特点</li><li>掌握如何使用封装,get,set方法</li></ul><h2 id="概述-1" tabindex="-1"><a class="header-anchor" href="#概述-1" aria-hidden="true">#</a> 概述</h2><p>封装（encapsulate）是指将数据及相关操作绑定在一起的一种编程机制，使其构成一个不可分割的独立实体。在Java中，类就是这样一种结构。当然，数据被保护在类的内部，是为了尽可能地隐藏内部的细节，只保留一些对外&quot;接口&quot;使之与外部发生联系。</p><p>把抽象出来的数据(属性), 和对数据的操作(方法)封装在一起, 数据被保护在内部, 程序的其他部分只有被授权的操作(方法), 才能对数据进行操作.</p><p><strong>封装的好处</strong></p><ul><li>使用者能够完全得到自己想要的功能，又不需要思考过多细节</li><li>实现者可以隐藏功能实现的细节，方便灵活进行修改而不影响使用者使用</li><li>可以对数据进行验证，保证安全合理</li></ul><h2 id="封装实现步骤" tabindex="-1"><a class="header-anchor" href="#封装实现步骤" aria-hidden="true">#</a> 封装实现步骤</h2><p>从实际的语法角度上来说，Java当中的封装是依赖于访问权限修饰符来实现：</p><ol><li><p>完全不需要被外界知道的属性(成员变量)，在类中完全可以私有化.(不能直接修改属性)</p></li><li><p>提供公共的(public) set方法, 用于对成员变量判断并赋值.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setXxx</span><span class="token punctuation">(</span>类型 参数名<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// Xxx表示成员变量名</span>
    <span class="token comment">// 加入数据验证的业务逻辑判断</span>
    成员变量名 <span class="token operator">=</span> 参数名<span class="token punctuation">;</span>
    <span class="token comment">// 一般使用this关键字完成赋值就可以了。</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>提供一个公共的(public) get方法, 用于获取成员变量的值</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">XX</span> <span class="token function">getXxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// 权限判断</span>
	<span class="token keyword">return</span> xx<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p><strong>总之，Getter/Setter方法使成员变量的读、写分离了，从原先的不可控变成了可控。在实际开发中，一个类的多数成员变量都是私有的，有必要时提供方法访问，无必要的则无需提供。</strong></p><ul><li>boolean 类型 为isXxx建议 布尔类型成员变量名 不要叫 isXxx</li></ul><h2 id="封装练习" tabindex="-1"><a class="header-anchor" href="#封装练习" aria-hidden="true">#</a> 封装练习</h2><p>基本使用:</p><p>定义一个员工Employer类, 类中有3个属性: 姓名 , 年龄 , 工资, 提供一个打印基本信息的public的方法</p><p>创建员工对象</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Employer</span><span class="token punctuation">{</span>
    <span class="token comment">// 成员变量</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span>
    
    <span class="token comment">// 打印基本信息的成员方法 </span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;员工信息: name:&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot; 年龄:&quot;</span> <span class="token operator">+</span> age
                <span class="token operator">+</span> <span class="token string">&quot; 工资: &quot;</span> <span class="token operator">+</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>练习一:</p><p>对上述例子进行修改, 要求通过无参构造方法去创建对象, 通过set方法对成员变量进行设置值, 要求年龄范围在1-100之间 , 工资在10K-15K范围内, 不在此范围内, 赋予默认值.</p><p>练习二:</p><p>对上述例子的基础上, 要求通过有参构造方法去创建对象, 要求年龄范围在1-100之间 , 工资在10K-15K范围内, 不在此范围内, 赋予默认值.</p><p>练习三:</p><p>定义一个银行账户类Account, 3个属性, 用户名, 密码, 余额.</p><p>要求用户名长度4-6位</p><p>密码长度6位</p><p>余额大于100</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Account</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> balance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h2><p>使用private私有化成员变量，并提供方法给外界访问时，需要注意：</p><ol><li><p>成员变量的访问权限应该尽量收紧，尽量私有化，当然有必要时也可以给外界权限直接访问。</p></li><li><p>对于boolean类型的成员变量来说，Getter方法的名字比较特殊，采用isXxx（Xxx是变量名）的形式。这时如果该boolean类型的成员变量本身就叫isXxx时，就会出现下面情况：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">boolean</span> isMale<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> flag<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> flag<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMale</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> isMale<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，在有些时候，就会导致程序误以为成员变量名为<code>male</code>的情况发生（实际为<code>isMale</code>）。所以在很多Java开发规范中，都明确建议boolean类型的成员变量名不要命名为<code>isXxx</code>。</p></li><li><p>Getter/Setter方法的写法显然十分固定，可以直接使用快捷键<code>Alt + Insert</code>快速生成。</p></li></ol><h1 id="继承-1" tabindex="-1"><a class="header-anchor" href="#继承-1" aria-hidden="true">#</a> 继承</h1><p>学习目标:</p><ul><li>继承的基本语法与特点</li><li>继承中2个类的关系</li><li>引用数据类型的类型转换</li><li>继承的层次</li><li>protected访问权限</li><li>子类对象初始化流程</li><li>继承中的属性隐藏</li><li>继承中的方法覆盖</li><li>final关键字的作用</li></ul><h2 id="引例" tabindex="-1"><a class="header-anchor" href="#引例" aria-hidden="true">#</a> 引例</h2><p>根据我们之前学过的知识，完成如下练习：</p><blockquote><p>分别定义一个表示人和学生的类：</p><ol><li>人类：有姓名属性，以及吃饭这个行为</li><li>教师类：有姓名，教师号两个属性，同时有吃饭，教学两种行为</li><li>学生类：有姓名，学号两个属性，同时有吃饭，学习两种行为</li></ol></blockquote><p>很明显，像成员变量name，方法eat等都是被重复定义的成员。既然有重复，那就想复用它们，现在的需求是：复用类的成员。怎么做呢？</p><p>Java中对代码的直接复用依赖于某一个方法，而想要复用类的成员，就必须使用Java中的继承语法。</p><p>为什么要复用代码？</p><blockquote><p>复用代码，不仅能够减少代码冗余，更重要的是能够更方便地修改代码，可维护性更强。</p><p>复用代码后，同样的代码在多处同时生效。</p></blockquote><h2 id="语法定义" tabindex="-1"><a class="header-anchor" href="#语法定义" aria-hidden="true">#</a> 语法定义</h2><p>基于已存在的类创建新的类，这个新的类会得到已存在的类的成员，并且可以自己添加新的成员，从而让新的类适应新的开发需求。这就是继承。继承的本质是成员的复用。</p><p>Java在定义一个类时，可以显式地，直接让它继承另一个类，这就是Java的继承机制，其语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> 类名 <span class="token keyword">extends</span> 被继承的类<span class="token operator">/</span>已经存在的某个类<span class="token punctuation">{</span><span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>说明：</p><ol><li><p>这个继承了一个已存在类的类，称之为子类。被继承的类称之为父类。</p></li><li><p>使用继承extends(扩展)关键字后，子类就获取到了父类的所有成员（成员变量和成员方法）.严格来说，继承只考虑对象相关成员的继承，静态成员我们先暂时不考虑。</p></li><li><p>子类在继承父类的同时，还可以自己定义新的成员，这叫做子类在父类的基础上进行扩展（所以子类往往比父类的功能更加强大，青出于蓝而胜于蓝。）</p></li><li><p>子类不能继承父类没有的成员。</p></li></ol><h2 id="继承中两个类的关系" tabindex="-1"><a class="header-anchor" href="#继承中两个类的关系" aria-hidden="true">#</a> 继承中两个类的关系</h2><h3 id="两个类的命名" tabindex="-1"><a class="header-anchor" href="#两个类的命名" aria-hidden="true">#</a> 两个类的命名</h3><p>在上一节中，我们已经讲到过，被继承的类称之为父类，继承父类的叫做子类。其实还有一些别的叫法，仅供了解。</p><ul><li><p>被继承的类主要称之为：</p><ul><li><strong>超类（Superclass）</strong></li><li>基类（Base Class）</li></ul></li></ul><p>注：</p><ul><li><p>需要注意，在外国Java圈中，更流行**超类（Superclass）**的叫法，查看英文文档中，你会很多Superclass。</p></li><li><p>继承其他类的类主要称呼有：</p><ul><li><strong>子类（Subclass）</strong></li><li>派生类（Derived Class）</li></ul></li></ul><h3 id="从属关系-重点" tabindex="-1"><a class="header-anchor" href="#从属关系-重点" aria-hidden="true">#</a> 从属关系(重点)</h3><p>从属关系（relation）上来说，继承中的父子类具有 <!----> 关系。即子类 <!----> 父类。子类可以近似地看成是一个父类，子类可以当作父类来使用.</p><p>那么如何理解这句话呢？我们从以下几个角度分析。</p><ul><li><p>从直观的逻辑角度解释：</p><ul><li>Student就是Person</li><li>Teacher就是Person</li><li>Cat也是Animal</li><li>Dog也是Animal</li></ul></li><li><p>实际代码书写角度解释：</p><ol><li>在正常情况下，创建谁的对象，就用谁的引用接收。</li><li>但是在具有父子类关系的两个类中，存在用父类引用接收子类对象的情况。</li><li>在这种情况下，子类对象被当成了父类对象去使用了。</li><li>即子类可以看成就是一个父类，也就是&quot;is-a&quot;关系。</li></ol></li><li><p>从数据类型的定义角度解释：</p><ol><li>数据类型是 一组数据 + 基于数据的操作</li><li>引用数据类型是 成员变量的集合 + 成员方法的集合</li><li>子类通过继承父类，得到了父类的所有成员，从数据类型上来说，子类就覆盖了父类的成员，具有了父类的功能。</li><li>子类可以当做父类去使用，也就是子类&quot;is-a&quot;父类。</li></ol></li></ul><!----><p><strong>注意:</strong></p><ul><li>父类能当子类用吗(父类&quot;is-a&quot;子类关系)？ <ul><li>显然不能，子类往往比父类功能要强大，父类不能当成子类使用</li></ul></li></ul><h2 id="引用数据类型的类型转换-重点" tabindex="-1"><a class="header-anchor" href="#引用数据类型的类型转换-重点" aria-hidden="true">#</a> 引用数据类型的类型转换(重点)</h2><p>子类对象是可以当成父类使用的，从逻辑角度上讲, 因为子类”is-a”父类</p><p>但从更具体的语法上来说，这个过程发生了引用数据类型的类型转换</p><p>基本数据类型存在类型转换, 引用数据类型同样存在.</p><h3 id="引用数据类型转换的前提" tabindex="-1"><a class="header-anchor" href="#引用数据类型转换的前提" aria-hidden="true">#</a> 引用数据类型转换的前提</h3><p><strong>===&gt; 继承</strong></p><p>引用数据类型的类型转换必须发生在具有父子关系的两个类之间，如果是没有继承关系的两个类，无法发生类型转换，只会导致编译报错。</p><p>换句话说, 继承打破了Java引用数据类型的类型限制, 有了继承, Java出现了引用数据类型的类型转换.</p><h3 id="转换的是什么" tabindex="-1"><a class="header-anchor" href="#转换的是什么" aria-hidden="true">#</a> 转换的是什么？</h3><p>引用数据类型变量 = 引用 + 对象</p><p>引用和对象都有对应的数据类型，但对象的类型可能被转换吗？</p><p>显然不可能，对象只能改变状态, 所以<strong>只可能是转换了引用的类型。</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 父类引用指向子类对象</span>
<span class="token class-name">Father</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 上述代码也可以写成：</span>
<span class="token class-name">Son</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Father</span> fs2 <span class="token operator">=</span> s<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="引用数据类型转换分类" tabindex="-1"><a class="header-anchor" href="#引用数据类型转换分类" aria-hidden="true">#</a> 引用数据类型转换分类</h3><p>引用数据类型的类型转换跟基本数据类型一样, 分类仍然是：</p><ul><li><p>自动类型转换</p></li><li><p>强制类型转换</p></li></ul><h4 id="自动类型转换" tabindex="-1"><a class="header-anchor" href="#自动类型转换" aria-hidden="true">#</a> 自动类型转换</h4><p>无需程序员写额外代码，编译器自动完成类型转换。</p><p><strong>自动类型转换的条件：</strong></p><ul><li>把子类的引用转换成父类的引用，由于子类&quot;is-a&quot;父类，所以这个过程不需要写额外代码，自动完成转换。</li></ul><p>子类引用转换成父类引用，在继承方向上是从下往上的。 所以引用数据类型的自动类型转换也称之为&quot;<strong>向上转型</strong>&quot;。</p><h4 id="强制类型转换" tabindex="-1"><a class="header-anchor" href="#强制类型转换" aria-hidden="true">#</a> 强制类型转换</h4><p>需要程序员写额外代码强制完成的类型转换。</p><p><strong>强制类型转换条件(通过编译的条件)：</strong></p><ul><li><p>把父类的引用转换成子类的引用时，显然父类不能随便作为子类使用。这个过程需要写额外代码完成，是强制类型转换。</p></li><li><p>强转额外代码的语法:</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>子类类型 子类的对象名 <span class="token operator">=</span> <span class="token punctuation">(</span>子类的类名<span class="token punctuation">)</span>父类引用
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>按照族谱一样把父类放在上面，子类处在下面。父类引用转换成子类引用， 在继承方向上是从上往下的。 所以引用数据类型的强制类型转换也称之为&quot;<strong>向下转型</strong>&quot;。</p><p><strong>注意：</strong></p><p>强转相当于把父类对象当子类对象去使用，这在绝大多数情况下是不可能的。所以引用数据类型的强制类型转换想要完成，条件会更加很苛刻, 可能会出现ClassCastException, 类型转换异常。</p><h2 id="继承的优缺点" tabindex="-1"><a class="header-anchor" href="#继承的优缺点" aria-hidden="true">#</a> 继承的优缺点</h2><p>这里给出一个继承语法的练习案例，通过案例我们来分析一下继承的优缺点：</p><blockquote><p>练习：</p><p>在一款游戏中，我们设计了三种类型的鸭子，这些鸭子有一些共同的属性，也有共同的行为，比如都可以叫，都会游泳等。</p><p>编写程序，描述这些鸭子。</p><p>后来，需求更改了，这些鸭子不能游泳了，但是都会飞，怎么改呢？</p><p>再后来，需求又改了，新增了一种鸭子，但这个鸭子不会飞，又怎么办呢？</p></blockquote><ul><li><p>继承的优点：</p><ul><li><p>继承的出现减少了代码冗余，提高了代码的复用性。</p></li><li><!----></li><li><p>扩展一点：</p><blockquote><p>继承的出现，对于Java的引用类型而言，弱化了类型的约束力，引用数据类型出现了数据类型转换的概念。</p><!----></blockquote></li></ul></li><li><p>继承的缺点：</p></li><li><p>子类继承父类必须无条件接收父类的所有成员，是没有选择的。</p><ul><li>父类中对成员进行修改，会严格体现到每一个子类中，我们不可选择具体哪个子类生效。</li></ul></li></ul><p>注：</p><p>当然对于成员方法而言，子类可以在继承父类成员方法之后，进行修改具体实现。称之为<span style="color:red;background:yellow;"><strong>&quot;方法的重写&quot;</strong></span>。</p><p>但重写归重写，继承仍然是继承了，没有办法不继承。</p><h2 id="继承的层次-重点" tabindex="-1"><a class="header-anchor" href="#继承的层次-重点" aria-hidden="true">#</a> 继承的层次(重点)</h2><h3 id="单继承" tabindex="-1"><a class="header-anchor" href="#单继承" aria-hidden="true">#</a> 单继承</h3><p>我们已经学习过了Java继承的基本语法，extends后面跟一个类名，表示继承了一个父类，那么很自然就会想到一个问题：</p><blockquote><p>Java中的一个类，能不能使用extends关键字同时继承多个类呢?</p></blockquote><p>非常简单，我们通过测试发现，这是做不到的。Java的语法规定一个类，在使用extends关键字直接继承某个类时，最多只能继承一个，即<strong>一个类只能有一个直接父类</strong>。（开个玩笑的说法，谁也没有两个亲爹吧？）</p><p>像Java这种，只能有一个直接父类，而不能有两个或更多的设计，称之为&quot;单重继承&quot;或者&quot;单继承&quot;。</p><p>而像C++当中，一个类可以直接继承多个类，就称之为&quot;多重继承&quot;或者&quot;多继承&quot;。</p><h3 id="继承层级" tabindex="-1"><a class="header-anchor" href="#继承层级" aria-hidden="true">#</a> <mark>继承层级</mark></h3><p>虽然直接父类只有一个，但Java中一个类仍然可以有很多个&quot;间接父类&quot;，因为父类可能还有父类。比如A继承B，B又继承了C，那么A的直接父类就是B，间接父类是C。于是就形成了下面几个概念：</p><ol><li>祖先类：处在继承顶层的类。</li><li>继承层次（hierarchy）：由某个祖先类派生出来的所有类的集合叫做继承层次。</li><li>继承链：从某一个子类开始，到其祖先类的路径。</li></ol><p><span style="color:red;background:yellow;"><strong>在Java中定义一个类，如果没有直接通过语法写出继承了Xxx类，那么它的直接父类就是——Object。</strong></span></p><p>Object类是Java所有类继承层次中顶层祖先类。Java中的每个类，都或直接，或间接的继承了Object。</p><p>所以, 我们在创建某个类对象, 调用其方法的时候, Idea给我们提示的时候, 会出现一些不属于该类的方法, 这些方法是哪来的? ---&gt; 继承自父类Object</p><p><strong>继承层次中需要注意的地方：</strong></p><ol><li>在一条继承链中，总称呼下游类是上游类的子类，不管隔了几层。没有孙子类或者重孙类这种概念。</li><li>在一条继承链中的，下游的类总是继承上游类的所有成员，不管隔了几层。</li><li>在一条继承链中，下游类总可以看成一个上游类，存在&quot;is-a&quot;关系。</li><li>不在同一条继承链中的类，没有任何关系。虽然看起来像&quot;兄弟姐妹&quot;类，但是Java是不讲究血统的。 <ul><li>因为一方面，子类可以自由扩展功能；另一方面，继承来的东西也是可以修改的。</li><li>所以&quot;兄弟姐妹&quot;可能完全和&quot;我&quot;不同，没有任何关系。</li></ul></li><li>不能循环定义继承。比如A继承B，B继承C，再让C来继承A，这是不行的。</li><li>继承链可以无限延伸下去，但是一般来说有个5~6层继承，已经很多了。</li></ol><h2 id="protected访问权限" tabindex="-1"><a class="header-anchor" href="#protected访问权限" aria-hidden="true">#</a> protected访问权限</h2><p>关于访问权限的概念，我们在面向对象基础时，已经提到过一次了。</p><p>但那时，我们还没有继承的概念，所以protected修饰符没有讲解。这里我们来补充讲解一下。</p><p>首先，我们回顾一下Java当中类中成员和构造器的四个访问权限等级：</p><ol><li>private：只能够在同一类中能够访问，私有的，外面谁都不能用。</li><li>（缺省的）不写任何关键字：同一包中的子类或者其它类能够访问，同包中都可以使用。</li><li>protected：<strong>不同包的子类能够访问。</strong></li><li>public：不同包的其他类能够访问，相当于没有做访问权限。</li></ol><p>用表格来描述这个访问权限就是：</p><table><thead><tr><th></th><th style="text-align:center;">public</th><th style="text-align:center;">protected</th><th style="text-align:center;">（缺省）</th><th style="text-align:center;">private</th></tr></thead><tbody><tr><td>同一类中</td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td></tr><tr><td>同一包其他类</td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td><td style="text-align:center;"></td></tr><tr><td>不同包子类</td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td>不同包其他类</td><td style="text-align:center;"><!----></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><h3 id="怎么理解不同包子类能够访问" tabindex="-1"><a class="header-anchor" href="#怎么理解不同包子类能够访问" aria-hidden="true">#</a> 怎么理解不同包子类能够访问</h3><p>protected关键字的使用定义上，很含糊的说了，protected修饰的成员在不同包的子类中可以访问，但实际上访问的方式仍然可以细分：</p><ol><li>不同包的子类中，创建父类对象，用父类对象访问protected成员。</li><li>不同包的子类中，创建该类的其他子类对象（&quot;兄弟姐妹对象&quot;），用这个其他子类对象访问父类的protected成员。</li><li>不同包的子类中，创建子类对象，用子类对象访问protected成员。</li></ol><p>我们可以创建以下Java类，来进行测试操作：</p><blockquote><ul><li>在包名为one的包中创建类： <ol><li>public class CurrentClazz，即当前类，是存放protected修饰的成员变量的父类。</li><li>public class SamePackageAnotherClazz，即同包下非子类。</li><li>public class SamePackageSonClazz，即同包下子类。</li></ol></li><li>在包名为another的包中创建类： <ol><li>AnotherPackageAnotherClazz，即不同包下非子类。</li><li>AnotherPackageSonClazz，即不同包下子类。</li></ol></li></ul></blockquote><p>类定义完毕后，就可以逐一测试，能否访问。</p><h3 id="结论" tabindex="-1"><a class="header-anchor" href="#结论" aria-hidden="true">#</a> 结论</h3><p>protected修饰的成员，在同类、同包下是可以随意访问的。</p><p>== 不同包下，必须在 子类当中，<mark>创建子类自身对象</mark>，才能使用 protected成员</p><p><span style="color:red;background:yellow;"><strong>但是在不同包下，必须在子类中，创建子类自身对象，才能够访问它从父类那里继承过来的protected成员，其它方式创建对象都不可以访问。</strong></span></p><hr><p>实际代码中，怎么查看protected成员的访问权限呢？</p><ol><li>先看是否同包中访问，只要同包就可以任意访问。</li><li>如果是非同包，一定要是子类中，才可以访问。而且必须是<!---->，才可以访问它继承自父类的protected成员。</li></ol><h3 id="为什么设置protected访问权限" tabindex="-1"><a class="header-anchor" href="#为什么设置protected访问权限" aria-hidden="true">#</a> 为什么设置protected访问权限</h3><p>在面向对象访问权限控制的整个体系中，实际上如果没有继承，那么只需要两个访问权限就足够了：要么是给别人用的public，要么是不给别人用的private。</p><p>但是有了继承后，<strong>如果类中的某个成员，非常有价值，我们希望这个成员总是被子类使用，而不会被滥用</strong>，出于保护这样一个成员的目的，protected就有意义了。</p><p>被protected修饰的成员，在不同包下（正常情况下，代码在使用时都不会同包），一定能够保证该成员被子类自身所使用：</p><ol><li>不能用父类的，创建父类对象访问不到。</li><li>不能用&quot;兄弟姐妹&quot;的，创建非自身的其它子类对象，也访问不到。</li></ol><p>这样就充分保证了<!---->想一想，将来有一天，你的财产也总是希望被亲近的人继承吧, 而且给它最大的控制权限吧</p><hr><p>注：既然子类有最大的控制权限，那么如果它愿意上交国家也是可以的。在子类中，可以重写从父类继承过来的方法的访问权限，可以选择从protected改写成public，这仍然属于方法的重写。（后面会讲）</p><h3 id="经典案例" tabindex="-1"><a class="header-anchor" href="#经典案例" aria-hidden="true">#</a> 经典案例</h3><p>Java所有类都直接或间接地继承了Object，也会同时继承它当中的一个protected修饰的成员方法clone()，那么在下面代码中分析使用对象调用clone()方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
     <span class="token comment">// 问题1: 这里能否创建Student对象,来调用clone方法?</span>
     <span class="token comment">/*
         Student类是Object类的子类,它继承了clone()方法
         但是它和Object类是非同包的关系
         不同包下: 必须在子类中,创建子类自身对象,才能够访问父类中继承过来的受保护成员
         在当前Demo类当中,叫在&quot;兄弟姐妹&quot;类中,创建对象,很明显不能访问,因为没有权限
      */</span>
     <span class="token class-name">Student</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">// &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;</span>
     <span class="token comment">// s.clone(); 不行</span>

     <span class="token comment">// 问题2: 这里能够调用谁的对象的clone()方法;</span>
     <span class="token class-name">Demo</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     d<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">// 当重写protected访问权限后,可以随意访问</span>
     <span class="token class-name">Teacher</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     t<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
     <span class="token comment">// 只能创建Student对象,来访问Student从Object类继承过来的clone方法</span>
     <span class="token comment">// new Demo().clone(); 不行</span>
     <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">{</span>
 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结论其实还是那句话：不同包下，必须在子类中，创建子类自身对象，才能访问从父类那里继承过来的protected成员。</p><p>上述代码还演示了方法重写——修改方法的访问权限，作为了解，后面会详细讲解。</p><h2 id="继承的限制" tabindex="-1"><a class="header-anchor" href="#继承的限制" aria-hidden="true">#</a> 继承的限制</h2><p>在前面，继承的定义中，我们说子类会继承父类的所有成员，那么思考以下问题：</p><ol><li><p>能不能继承父类的私有成员呢？</p><p>首先，直接访问是访问不到的。 <!----></p></li><li><p>能不能继承父类的构造器呢？</p><p>首先构造器不能算成员，况且构造方法也不是普通方法，继承过来干嘛呢？构造器是不能被继承的。</p></li><li><p>能不能继承父类的静态成员呢？</p><p>对于下列代码，我们测试一下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 以下访问可行,并且结果确实是10</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Son</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，<!---->，直接用子类类名点访问，是可以访问到父类中的静态成员的。<span style="color:red;background:yellow;"><strong>但这仅意味着子类能够使用父类的静态成员，并不意味着继承！</strong></span>通常情况下，继承仅考虑普通成员而不考虑静态成员。</p></li></ol><h2 id="子类对象的初始化-重点" tabindex="-1"><a class="header-anchor" href="#子类对象的初始化-重点" aria-hidden="true">#</a> 子类对象的初始化(重点)</h2><p><strong>我们先复习一下我们认识引用数据类型的过程：</strong></p><ol><li><p>首先我们从数组对象的初始化开始，我们知道引用数据类型变量分为两个部分，在堆上创建对象，在栈中创建引用，引用通过存储地址指向堆上的对象。对象是引用数据类型的实质，但是我们不能直接访问对象，而是通过栈上的引用间接访问堆上的对象。</p></li><li><p>然后我们学习了对象与类的概念，引入了类加载的概念。并且使用数据类型的定义统一了引用数据类型和基本数据类型：</p><p>数据类型：一组数据 + 基于数据的一组合法操作</p><p>引用数据类型：成员变量的合集 + 成员方法的合集</p><p>也就是说，引用数据类型（类）是特殊的数据类型，是自定义的数据类型。这种自定义的数据类型JVM不认识它，需要一个了解认识它的过程，称之为类加载。</p><p>JVM通过类加载了解一个类型，从而能够完成创建对象，或者其它的一些操作。</p></li><li><p>现在我们学习了继承的概念，在继承中，子类会继承父类的成员，<!---->。那么问题就来了：</p><ol><li>父类的成员从何而来？凭空出现？</li><li>父类的成员变量也需要赋值，那么赋值顺序是怎么样的？结果是怎么样的？为什么会体现出这种特点？</li></ol></li></ol><p>以上问题就是子类对象的初始化问题，即研究子类对象创建时，父类的成员从何而来，父类成员变量的赋值等相关的问题。</p><hr><p>我们通过一个引例，练习来讲解这个问题：</p><blockquote><ol><li>创建一个Person类，有name属性和eat方法</li><li>创建一个Star类，有stageName属性和sing方法</li><li>Star类要继承Person类</li><li>创建Star类对象，画出这个过程的内存图，描述子类对象初始化的过程</li></ol></blockquote><figure><img src="/assets/image-20230209145801368-864fd11a.png" alt="image-20230209145801368" tabindex="0" loading="lazy"><figcaption>image-20230209145801368</figcaption></figure><h3 id="子类对象初始化流程" tabindex="-1"><a class="header-anchor" href="#子类对象初始化流程" aria-hidden="true">#</a> 子类对象初始化流程</h3><p>在创建子类Star对象的过程中，首先要考虑的就是类加载。Star这个类肯定是需要进行类加载的，但Star还有父类Person。子类对象能够直接访问父类成员，显然父类成员究竟有哪些，都是些啥，这些信息JVM是需要知道的（不如如何创建？）。</p><p>所以：</p><p><span style="color:red;background:yellow;"><strong>子类的类加载会触发父类的类加载，并且类加载的顺序是&quot;先父后子&quot;的。</strong></span></p><p>这里，我们可以总结类加载的时机：</p><ol><li>启动main方法</li><li>创建对象(首次)</li><li>访问类的静态成员(首次)</li><li>子类类加载会触发父类类加载（不管子类是何种方式触发类加载）</li></ol><hr><p><strong>流程</strong></p><ol><li>父子类加载(先父后子)</li><li>创建子类对象 <ul><li>子类对象中会专门开辟一片独立的区域，用来存储父类的成员变量(父类成员区域, <strong>近似</strong>看成一个父类对象, 被super关键字指向, <strong>近似</strong>看做super指向当前子类对象的父类对象)</li><li>子类自身的成员仍会存储在自身对象当中(this指向当前子类对象)</li></ul></li><li>父子类成员赋值(先父后子) <ul><li>默认初始化</li><li>显式赋值</li><li>构造代码块赋值</li><li>构造器赋值</li></ul></li></ol><p><strong>原理</strong></p><ul><li><p>成员变量赋值先父后子如何保证?</p><ul><li>父类构造器优先于子类构造器执行</li></ul></li><li><p>父类的构造器为什么优先于子类构造器执行?</p><ul><li><p>super关键字可以在<strong>子类构造器或成员方法</strong>中，用于<strong>调用父类构造器或者访问父类成员</strong>。</p></li><li><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 语法:</span>
<span class="token keyword">super</span><span class="token punctuation">(</span>实参列表<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在一个类中的构造器中,如果构造器第一行没有直接用this/super去调用其他构造器,那么它一定隐含语句: super() 表示调用父类的无参构造器</p></li><li><p>这种程序员没有写任何代码,通过隐含super()的形式,来完成子类对象初始化的方式称之为**&quot;子类对象的隐式初始化&quot;**, 子类对象的隐式初始化是调用父类无参构造器实现的</p></li><li><p>无参构造器是不能给成员变量赋值的, 在创建子类对象时,如果希望能够给父类成员赋值,就必须调用父类的有参构造器, 在子类构造器第一行写 super(实参列表), 直接指出调用父类哪个构造器的子类对象创建方式,称之为**&quot;子类对象的显式初始化&quot;**</p></li></ul></li></ul><hr><h3 id="隐式子类对象初始化" tabindex="-1"><a class="header-anchor" href="#隐式子类对象初始化" aria-hidden="true">#</a> 隐式子类对象初始化</h3><p>父子类成员变量的赋值顺序的&quot;先父后子&quot;，是通过父子类构造器调用的&quot;先父后子&quot;保证的。但是注意 <!----></p><blockquote><!----></blockquote><p><strong>那么父类所有的成员变量的赋值方式都是先于子类成员变量的任何赋值方式（默认初始化除外）</strong>，于是自然父类成员变量的赋值顺序都会先于子类的。</p><hr><p>在创建上述Star类对象时，我们没有在代码的任何位置，表示将要去调用父类构造器，但实际上父类构造器仍被调用了。这是为什么呢？</p><p>在Java的任何构造器当中，如果第一行没有明确的去调用别的构造器（通过this或super关键字）</p><p>那么第一行一定隐含了一条语句：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该行语句表示去调用父类的无参构造方法。于是，在子类对象初始化时，就会保证先去执行父类构造方法。这样就能够保证，父类成员变量的赋值一定先于子类。由于，程序员没有写任何代码，这种子类对象的初始化方式，称之为——&quot;子类对象的隐式初始化&quot;。</p><hr><p><strong>隐式对象初始化的必要条件：</strong></p><ol><li>父类中有默认的构造方法</li><li>子类的构造器中没有显式使用super调用父类的构造方法，也没有用this去调用自己的构造方法。</li></ol><p>达成上述两个条件，则JVM在初始化子类对象时进行隐式初始化，永远先执行父类的构造方法，顺序为：</p><ol><li>最上层的父类（Object）</li><li>其他父类（继承链中越处于上流越先执行）</li><li>所有父类的构造方法都执行完毕，开始执行子类构造方法</li></ol><h3 id="显示子类对象初始化" tabindex="-1"><a class="header-anchor" href="#显示子类对象初始化" aria-hidden="true">#</a> 显示子类对象初始化</h3><p>子类对象的隐式初始化是调用父类无参构造方法，所以如果需要给父类成员变量直接赋值是做不到的， <span style="color:red;background:yellow;"><strong>所以就需要子类对象的显式初始化。即明确在子类构造器的第一行，用super(参数)，明确指出调用父类的某个构造方法来完成父类成员变量的赋值。</strong></span></p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">super</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>注意事项：</p></blockquote><ol><li>super在构造器中用于表示调用父类构造器时，例如super(参数)，该条语句必须在第一行。</li><li>this在构造器中用于表示调用自身构造器时，例如this(参数)，该条语句必须在第一行。</li><li>显然super、this两个关键字在表示调用构造器时，是绝不可能共存的。</li></ol><h3 id="super关键字" tabindex="-1"><a class="header-anchor" href="#super关键字" aria-hidden="true">#</a> super关键字</h3><blockquote><p>什么是super关键字？</p></blockquote><p>上面其实已经说过了，你完全可以直接把super关键字，看成指向当前类的父类&quot;对象&quot;的一个引用。即：</p><ol><li>this代表当前类的当前对象。</li><li>super表示当前类的父类对象。</li></ol><hr><p>super和this的使用几乎没有差别，只不过一个表示子类对象，一个表示父类对象。比较大的区别是：</p><ol><li><p>super只能访问父类中有的成员，特殊情况下，当父子类具有同名成员时，可以用super区分。</p></li><li><p><span style="color:red;background:yellow;"><strong>this在当前类中不受访问权限控制，super访问父类成员，受访问权限控制。</strong></span></p></li><li><p>this毕竟还是一个引用，指向当前对象，所以可以直接在类中成员方法中输出它。</p><blockquote><p><span style="color:red;background:yellow;"><strong>但是super毕竟没有指向对象，无法直接输出它！</strong></span></p></blockquote></li></ol><p>具体的使用可以参考下面表格：</p><table><thead><tr><th></th><th style="text-align:center;">含义</th><th style="text-align:center;">构造器调用</th><th style="text-align:center;">成员访问</th><th style="text-align:center;">是否受权限控制</th></tr></thead><tbody><tr><td>this</td><td style="text-align:center;">当前对象的引用</td><td style="text-align:center;">this(参数)，表示调用自身构造器</td><td style="text-align:center;">this.</td><td style="text-align:center;">否</td></tr><tr><td>super</td><td style="text-align:center;">父类对象（近似）的引用</td><td style="text-align:center;">super(参数)，表示调用父类构造器</td><td style="text-align:center;">super.</td><td style="text-align:center;">是</td></tr></tbody></table><h3 id="练习" tabindex="-1"><a class="header-anchor" href="#练习" aria-hidden="true">#</a> 练习</h3><p>分析程序的执行顺序：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">PrimaryStudent</span> primaryStudent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrimaryStudent</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">,</span><span class="token number">888</span><span class="token punctuation">,</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>primaryStudent<span class="token punctuation">.</span>psVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
<span class="token keyword">static</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Person类加载&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Person构造代码块&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Person类的无参构造&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
<span class="token keyword">static</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Student类加载&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Student构造代码块&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> sVar<span class="token punctuation">;</span>
<span class="token class-name">String</span> sVarString<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Student类无参构造&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> sVar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Student int构造方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sVar <span class="token operator">=</span> sVar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> sVar<span class="token punctuation">,</span> <span class="token class-name">String</span> sVarString<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">(</span>sVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Student int String构造方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sVarString <span class="token operator">=</span> sVarString<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">PrimaryStudent</span> <span class="token keyword">extends</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
<span class="token keyword">static</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;PrimaryStudent类加载&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;PrimaryStudent构造代码块&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> psVar <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">PrimaryStudent</span><span class="token punctuation">(</span><span class="token keyword">int</span> psVar<span class="token punctuation">,</span> <span class="token keyword">int</span> sVar<span class="token punctuation">,</span> <span class="token class-name">String</span> sVarString<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">super</span><span class="token punctuation">(</span>sVar<span class="token punctuation">,</span> sVarString<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;PrimaryStudent类的 三参构造&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>psVar <span class="token operator">=</span> psVar <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先父后子，父类构造器执行完毕，才能轮到子类。当然父类如果有多个，就从最顶层父类开始。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p><strong>无论是隐式还是显式子类对象初始化，最终都是为了保证父类构造器先于子类执行。</strong></p><p><span style="color:red;background:yellow;"><strong>总结一下到目前为止，创建对象过程中可能碰到的结构的执行顺序（最全）：</strong></span></p><p>我们将程序的运行分成两部分：</p><!----><ol><li><p>首先程序要从main方法启动，这意味着首先要触发，装有main方法的那个类的类加载。</p><p>类加载过程中，一定要考虑连环触发类加载的情况：</p><ol><li>类中有静态成员变量创建对象，那么一定会触发其它类的类加载。</li><li>该类还有父类，于是触发父类类加载。</li></ol></li><li><p>类加载这个过程中，静态代码块的代码一定会执行，不要忘记了。</p></li><li><p>如果有静态成员变量的显式赋值，那么显式赋值和静态代码块，按照代码的书写顺序从上往下执行。</p></li><li><p>类加载整个程序运行期间只有一次，如有通过继承连环触发类加载，那么顺序是<code>先父后子</code>，从最顶层父类开始。</p></li></ol><!----><ol><li>切记类加载是懒加载，有些类可能等到main方法执行到一半才触发类加载。 <ul><li>这个就要随机应变了，以下步骤，都默认类加载全部结束了。</li></ul></li><li>new对象时，首先去找到new对象的构造器，然后观察第一行 <ol><li>如果它的首行显式地调用了另一个构造器（可能是<code>this(参数)</code>，也可能是<code>super(参数)</code>） <ul><li>那么程序会先跳转到那个构造器，再去看代码首行有没有显式调用另一个构造器 <ul><li>直到找到一个构造器它隐含的super()指向Object类的无参构造</li><li>于是开始按照这个类中构造代码块和显式赋值的代码书写顺序，从上到下执行其中的代码</li><li>最后执行这个类的构造器</li></ul></li><li>开始执行被跳转的构造器，同样先执行显式赋值和构造代码块后执行构造器</li><li>最后执行完new对象构造器，创建对象过程结束。</li></ul></li><li>如果它的首行没有显式调用另一个构造器，那么必定隐含<code>super()</code>指向父类的无参构造器。 <ul><li>如果直接指向Object类的无参构造，那十分简单，直接不用管 <ul><li>执行类中的显式赋值和构造代码块，最后执行构造器</li></ul></li><li>如果指向一个普通父类的无参构造，那就观察首行，根据情况执行</li><li>最终一定父类构造器执行完毕，回到new对象的类中，执行完毕new对象构造器，创建对象过程结束。</li></ul></li></ol></li></ol><hr><p>总之，先父后子记住，在某一个类中成员变量赋值中，构造器最后去执行。</p><h2 id="继承中的属性隐藏" tabindex="-1"><a class="header-anchor" href="#继承中的属性隐藏" aria-hidden="true">#</a> 继承中的属性隐藏</h2><h3 id="引例-1" tabindex="-1"><a class="header-anchor" href="#引例-1" aria-hidden="true">#</a> 引例</h3><p>在上面章节中，我们已经知道，父子类的成员是允许同名的。那么如果父子类属性同名了，那么不使用super区分，直接访问的效果是什么样的呢？</p><p>现在我们直接创建子类对象，使用子类引用接收。会发现访问的结果是子类中属性的取值，那么父类中的那个成员变量去哪了呢？首先它肯定是存在的，这一点随便写一个父类成员变量的Getter方法就可以验证了。这说明使用 &quot;对象名点&quot;访问成员变量 这个语法，可能存在一些特殊的机制，接下来我们就来探讨这种机制。</p><h3 id="对象名-成员变量的访问机制" tabindex="-1"><a class="header-anchor" href="#对象名-成员变量的访问机制" aria-hidden="true">#</a> 对象名.成员变量的访问机制</h3><p>在研究 <!----> 机制时，我们主要探究两个方向：</p><ol><li>访问范围，究竟能够访问到哪些成员变量？根据什么来决定？</li><li>访问结果，如果是父子类同名成员变量，那么结果是什么？根据什么来决定？</li></ol><hr><p>首先是 <!----> ，对象的由来，可以有三种方式：</p><ol><li>创建父类对象,用父类引用接收，用对象名点访问。</li><li>创建子类对象,用子类引用接收，用对象名点访问。</li><li>创建子类对象,用父类引用接收，用对象名点访问。</li></ol><h3 id="属性隐藏" tabindex="-1"><a class="header-anchor" href="#属性隐藏" aria-hidden="true">#</a> 属性隐藏</h3><h4 id="访问范围机制" tabindex="-1"><a class="header-anchor" href="#访问范围机制" aria-hidden="true">#</a> 访问范围机制</h4><p>经过上面的测试，我们可以知道对象名点成员变量，它的访问范围是由 <!----> 来决定的。</p><ol><li>如果引用是父类类型，那么它的访问范围只有父类（和父类的父类）。</li><li>如果引用是子类类型，那么它的访问范围是子类 + 父类（父类如果还有父类也算上）。</li></ol><hr><p>在Java当中，对象名点访问成员变量的范围是编译器决定的，是一个编译上的概念。编译在检索一个引用是否能够访问到某个成员变量时，存在以下检索机制：</p><ol><li>首先编译器会从<strong>引用的数据类型</strong>的那个类中，去查找该成员变量。如果找到了，就直接认为它可以访问。（有权限才行）</li><li>如果没有找到，那么就去父类中找。直到找到Object类，如果Object类当中都没有该成员变量，那就会编译报错。</li></ol><p>上述规则，实际上可以总结为：</p><p>在Java中，访问范围是可以往上查找父类的，但不能往下找子类。 <span style="color:red;background:yellow;"><strong>子类知道自己的&quot;爸爸&quot;是谁，但&quot;爸爸&quot;并不知道它有这个&quot;儿子&quot;，甚至都不知道自己有几个&quot;儿子&quot;，或者有没有&quot;儿子&quot;。</strong></span></p><h4 id="访问结果机制" tabindex="-1"><a class="header-anchor" href="#访问结果机制" aria-hidden="true">#</a> 访问结果机制</h4><p>对象名点成员变量，访问的结果也是由 <!----> 来决定的。</p><ol><li>如果引用是父类类型，那么它的访问结果一定也是父类中的结果。</li><li>如果引用是子类类型，那么它的访问结果一定也是子类 + 父类中的结果。</li></ol><h4 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结</h4><p>综合对象名点访问成员变量的范围和结果，发现：<span style="color:red;background:yellow;"><strong>都是根据引用的数据类型来决定的，无需考虑是何种对象。</strong></span></p><p>注意事项：</p><ol><li><p>父子类中的同名成员变量它们各自有存储的区域，父类的同名成员变量被子类同名成员变量隐藏了，称之为&quot;属性的隐藏&quot;。</p><p>但我们仍然可以通过父类中的Getter方法，或者通过super去访问到父类中同名成员变量，当然它们都受访问权限限制。</p></li><li><p>静态成员变量在父子类中也存在同名的情况，但是它们不是覆盖也不是隐藏，而是互相独立的两个静态成员变量。</p><p>对于下列代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token class-name">String</span> nationality<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
   
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>	
    <span class="token keyword">static</span> <span class="token class-name">String</span> nationality<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Person类和Student类的<mark>静态成员变量</mark><strong>国籍分别属于两个类本身，没有所谓继承关系</strong>。</p><p>而如果是下列代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token class-name">String</span> nationality<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
   
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Person类和Student类都可以使用Person类的静态成员变量国籍，是共用的关系。</p></li></ol><h2 id="继承中的方法覆盖" tabindex="-1"><a class="header-anchor" href="#继承中的方法覆盖" aria-hidden="true">#</a> 继承中的方法覆盖</h2><h3 id="引例-2" tabindex="-1"><a class="header-anchor" href="#引例-2" aria-hidden="true">#</a> 引例</h3><p>在上一节一样，父子类中的成员方法也是可以同名的。那么我们直接创建子类对象，使用子类引用接收。调用同名方法，会发现访问的结果是子类中方法的行为，那么父类中的那个同名成员方法去哪了呢？还能够访问吗？首先它肯定是存在的，方法不过是方法区的二进制指令合集罢了，类加载时期，装载进方法区，不会物理消失。但 <!----> 这个语法还是和访问成员变量是有很大区别的， 我们可以写一个public方法，然后在方法中访问同名成员方法，最后测试调用这个public方法，如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;father test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">invokeFatherTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：test是那个同名的成员方法</p><p>我们会发现，方法调用的结果仍然体现子类中的方法行为，这就有点意思了。接下来我们就来探讨一下这种 <!----> 的机制。</p><h3 id="对象名-成员方法的访问机制" tabindex="-1"><a class="header-anchor" href="#对象名-成员方法的访问机制" aria-hidden="true">#</a> 对象名.成员方法的访问机制</h3><p>和前面访问成员变量一样，在研究 <!----> 机制时，我们主要探究两个方向：</p><ol><li>访问范围，究竟能够访问到哪些成员方法？根据什么来决定？</li><li>访问结果，如果是父子类同名成员方法，那么结果是什么？根据什么来决定？</li></ol><hr><p>首先是 <!----> ，对象的由来，可以有三种方式：</p><ol><li>创建父类对象,用父类引用接收，用对象名点访问。</li><li>创建子类对象,用子类引用接收，用对象名点访问。</li><li>创建子类对象,用父类引用接收，用对象名点访问。</li></ol><h4 id="访问范围机制-1" tabindex="-1"><a class="header-anchor" href="#访问范围机制-1" aria-hidden="true">#</a> 访问范围机制</h4><p>实际上不管是，属性的访问还是成员方法的访问，范围都是一个编译上的概念，所以结果即便不测试也是和，上节中属性的访问范围是一样的。当然，测试后结果仍然是：对象名点成员方法，它的访问范围是由 <!----> 来决定的。</p><ol><li>如果引用是父类类型，那么它的访问范围只有父类（和父类的父类）。</li><li>如果引用是子类类型，那么它的访问范围是子类 + 父类（父类如果还有父类也算上）</li></ol><h4 id="访问结果机制-1" tabindex="-1"><a class="header-anchor" href="#访问结果机制-1" aria-hidden="true">#</a> 访问结果机制</h4><p>对象名点成员方法，访问的结果就不再是由 <!----> 来决定了，而是根据 <span style="color:red;background:yellow;"><strong>对象的实际类型</strong></span> 来决定。</p><ol><li>如果对象是一个子类类型，那么即便引用是父类，方法调用也要体现出子类的行为。</li><li>反之如果对象是一个父类类型，方法调用的结果就是父类行为。</li><li>为了 <mark>体现方法的覆盖</mark></li></ol><h4 id="总结-2" tabindex="-1"><a class="header-anchor" href="#总结-2" aria-hidden="true">#</a> 总结</h4><p>综合对象名点访问成员方法的范围和结果，发现：</p><ol><li>访问范围仍然是要靠 <!----> 来决定。</li><li><span style="color:red;background:yellow;"><strong>但是方法的调用结果，就需要考虑对象的具体类型，是何种对象，就体现出它的行为。</strong></span></li></ol><p>注意事项：</p><ol><li>父子类中一旦存在父子类同名的成员方法，那么只要创建子类对象，在任何位置都无法再直接用对象名.访问到父类成员方法了，这就是继承中的方法的覆盖。</li><li>方法的调用之所以体现为覆盖，这是因为方法的调用结果是根据对象的实际类型决定的，和引用没有任何关系。</li><li>当然，方法的覆盖不是物理意义上的覆盖，只是方法的访问机制决定的。这个父类中的同名方法，仍然可以使用super关键字去访问到，当然前提是有访问权限。</li></ol><p>结合我们前面封装的思想，实际开发中，大多数的成员变量都是私有化的，这意味着使用 <!----> 的机会是很罕见的，多数情况下我们都是在调用方法完成各种功能。<span style="color:red;background:yellow;"><strong>方法的覆盖是非常重要的知识点，如果说继承是面向对象的核心，那么继承应该就属于方法的覆盖。接下来讲解方法覆盖的语法。</strong></span></p><h3 id="方法的覆盖-重写" tabindex="-1"><a class="header-anchor" href="#方法的覆盖-重写" aria-hidden="true">#</a> 方法的覆盖/重写</h3><p>方法的覆盖，也叫方法的重写（override），指的是在子类中，能够改写父类成员方法的内容。从形式上表现出来，就是父子类中能够拥有同名的成员方法。</p><p>在讲解具体的方法重写的语法和使用之前，我们要先讲解一个注解：<code>@Override</code>，就和它的名字一样，这个注解写在子类的方法头上，用于检测子类中的某个方法，是否是父类方法的重写。例如下列代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 父类方法</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;father&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 子类方法</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;son&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际开发中，我们要求大家，在任何时候，<strong>只要是在做方法的重写，就一定要加上注解</strong><code>@Override</code>，好处是：</p><ol><li>能够检测语法，如果因为没加注解，导致将本不是方法重写的方法，误以为是方法重写，将会带来错误。</li><li>提升代码可读性，加了该注解的方法一定是重写自父类的方法。</li></ol><h4 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h4><p>方法的重写的语法要求，对于下列一个成员方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 成员方法的语法</span>
<span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token comment">//方法体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p>子类中重写的方法，访问权限等级，必须至少保持一致，<mark>可以更为宽松</mark>，但一定不能更严格。</p></li><li><p>子类中重写的方法，返回值类型必须和原先父类方法的返回值类型，保持兼容(引用数据类型,不涉及基本数据类型)。</p><p>注：何为兼容呢？这里留给大家思考~</p></li><li><p>子类中重写的方法，方法名必须严格保持一致，不能做任何修改。</p></li><li><p>子类中重写的方法，形参列表必须保持严格一致，不能做任何修改。</p></li><li><p>方法体的代码，无所谓，可以保持一致，也可以修改。</p></li></ol><h4 id="注意事项-1" tabindex="-1"><a class="header-anchor" href="#注意事项-1" aria-hidden="true">#</a> 注意事项</h4><ul><li>父类中私有方法不能被重写（因为没有权限访问，更不谈重写）</li><li>静态方法在使用现象上，很像是被重写了，但实际上静态方法不能被重写，而是直接是一个新的静态成员。（使用<code>@Override</code>注解标记会报错）</li><li>构造器不能继承，更不能被重写。</li><li>快捷方式： <ul><li>直接在子类中，手写出父类方法的名字。看到出现父类方法提示，直接回车即可重写。</li><li>使用快捷键<code>Alt + Insert</code>，在选项<code>Override Methods</code>中，选择重写子类的方法。</li></ul></li></ul><h4 id="方法重写-vs-方法重载" tabindex="-1"><a class="header-anchor" href="#方法重写-vs-方法重载" aria-hidden="true">#</a> 方法重写 VS 方法重载</h4><p>最后，在这里做一个扩展。回想一下我们之前学过的<code>方法的重载</code>，它和<code>方法的重写</code>语法上有什么区别呢？</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">方法的重载（overload）</th><th style="text-align:center;">方法的重写（override）</th></tr></thead><tbody><tr><td style="text-align:center;">发生的类不同</td><td style="text-align:center;">必须在同类中</td><td style="text-align:center;">必须发生在父子类之间，肯定不是同一个类中</td></tr><tr><td style="text-align:center;">方法名</td><td style="text-align:center;"><strong>必须相同</strong></td><td style="text-align:center;"><strong>必须相同</strong></td></tr><tr><td style="text-align:center;">参数列表</td><td style="text-align:center;"><strong>必须不同</strong></td><td style="text-align:center;"><strong>必须相同</strong></td></tr><tr><td style="text-align:center;">访问权限修饰符</td><td style="text-align:center;"><strong>不影响，无所谓</strong></td><td style="text-align:center;">子类方法的访问权限，不允许更严格（可以一致或宽松）</td></tr><tr><td style="text-align:center;">返回值类型</td><td style="text-align:center;"><strong>不影响，无所谓</strong></td><td style="text-align:center;">子类方法返回值类型保持兼容，不用完全一致</td></tr><tr><td style="text-align:center;">异常</td><td style="text-align:center;"><strong>不影响，无所谓</strong></td><td style="text-align:center;"><strong>重写的方法不能抛出更多的异常</strong></td></tr></tbody></table><h4 id="练习-1" tabindex="-1"><a class="header-anchor" href="#练习-1" aria-hidden="true">#</a> 练习</h4><p>读程序</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Son</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Son</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Father</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Father</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 该行在执行时,如果创建的是子类对象,</span>
        <span class="token comment">// 那么子类的任何赋值手段都没有执行,那子类中的num一定是0</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="final关键字" tabindex="-1"><a class="header-anchor" href="#final关键字" aria-hidden="true">#</a> final关键字</h2><p>final有最终的、最后的意思。它是一个修饰符，可以用来修饰：</p><ol><li>class类</li><li>方法</li><li>变量（包括成员变量、静态成员变量和局部变量）</li></ol><p>它修饰不同结构时含义是不同的，下面详细了解一下。</p><h3 id="final修饰类" tabindex="-1"><a class="header-anchor" href="#final修饰类" aria-hidden="true">#</a> final修饰类</h3><p>final修饰类时，表示最后的类，最终的类。即表示这个类不能被继承。</p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">final</span> <span class="token keyword">class</span> 类名<span class="token punctuation">{</span>
<span class="token comment">//类体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p><ul><li><p>思考：什么样的类需要设置成final？</p><p>不需要，不想要被子类继承的类，才需要设置为final修饰。当你认为当一个类的设计已经足够完善，功能足够强大了，不需要再让子类去扩展它了。这时出于安全的考虑，就可以将一个类设置为final。这样类中成员，既不会被继承，更不会被修改。</p></li><li><p>正常情况下，我们很少会主动把一个类设置成final，因为没有太多的必要性。实际开发中，也要慎重将一个类设置final。</p></li><li><p>常见的final修饰的类，都在JDK的源码当中。比如四类八种基本数据类型的包装类、Void、String、System、Scanner等等。</p></li></ul><h3 id="final修饰方法" tabindex="-1"><a class="header-anchor" href="#final修饰方法" aria-hidden="true">#</a> final修饰方法</h3><p>final修饰方法表示最后的方法，最终的方法，表示该方法无法被重写 <span style="color:red;background:yellow;"><strong>（但是仍然可以被继承）</strong></span>。</p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">final</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//方法体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p><ul><li>final修饰成员方法，表示该方法无法被重写，但是仍然是可以继承的。</li><li>什么样的成员方法应该设置为final呢？ <ol><li>方法的设计已经比较完善，不需要子类进行修改了，子类只需要乖乖继承，使用父类的实现即可。比如一旦修改就会导致问题、bug等时，就可以设置为final修饰。</li><li>即便是父类的方法不是很完善，但只要是希望子类不要改写方法都可以这么做。（要么你就用，不爽你就自己实现一个）</li></ol></li><li>日常开发，程序员还是比较少见有需要把方法设置成final修饰的。同样比较多见于JDK源码中，比较常见的有：像Object类中的getClass()方法.</li></ul><hr><p>注意：</p><p>并不是随便拿一个方法都能用final修饰的，比如：</p><ol><li>private方法，本来就无法重写，不需要多此一举。（可以修饰，但是会报警告）</li><li>static方法，本来就无法重写，不需要多此一举。（可以修饰，但是会报警告）</li><li>构造方法，不能被继承，更不能重写，加final修饰会编译报错。</li></ol><h3 id="final修饰变量" tabindex="-1"><a class="header-anchor" href="#final修饰变量" aria-hidden="true">#</a> final修饰变量</h3><p>final修饰变量，表示最后的变量，最终的变量，即表示常量。（表示在整个程序期间，值不会再变了）</p><p>**final修饰变量时可以修饰局部变量，成员变量，静态成员变量。**总体上来说，要注意下述三个细节：</p><ul><li>常量的分类 <ul><li>字面值常量：1，2.0，3，&quot;hello&quot;等</li><li>自定义常量： <strong>被final修饰的变量，就是自定义常量。</strong></li></ul></li></ul><p>自定义常量的命名：单词全部大写，两个单词之间用&quot;_&quot;隔开。</p><p>自定义常量的命名规范，不要求严格遵守，因为即便是JDK中的源码也没有百分百遵守。从实际开发角度出发， <strong>建议成员静态常量，即final修饰静态成员变量时，遵守命名规范，其它常量随意。</strong></p><ul><li><p>自定义常量，不会更改变量的存储位置，生命周期，使用方式等等。唯一改变就是值从能改变，变成不能改变。</p><ul><li>成员变量 ----&gt; 成员常量</li><li>局部变量 ----&gt; 局部常量</li></ul></li><li><p>final修饰变量时，可以修饰基本数据类型变量，也可以修饰引用数据类型。</p><ul><li>修饰基本数据类型时，很容易理解，值不变。</li><li><strong>修饰引用数据类型时，修饰的是引用而不是对象，表示引用中存储的地址成为一个常量，不可更改</strong>。这意味着引用指向的对象不可更改了，不能再指向一个新的对象了。但对象中成员变量的取值仍是可以修改的。（对象的状态仍可变）</li></ul></li></ul><p>接下来，分情况讨论final修饰变量。</p><h4 id="修饰局部变量" tabindex="-1"><a class="header-anchor" href="#修饰局部变量" aria-hidden="true">#</a> 修饰局部变量</h4><p>我们以方法中的局部变量为例子，方法中的局部位置有两个：</p><ul><li>方法体： <ul><li>方法体中用final修饰局部变量，表示该变量一旦声明并初始化赋值，就不可再修改它的取值了。</li><li>语法上，直接使用final修饰即可。</li></ul></li><li>方法的形参列表中： <ul><li>形参用final修饰后，不是表示该方法只能传入常量，而是实参一旦传入后就无法在方法体中修改了。</li><li>语法上，直接使用final修饰即可。</li></ul></li></ul><p><strong>注意：</strong></p><p>final修饰局部变量后，会变成一个局部常量。仍然在方法栈帧中创建存储，随着方法同生共死，除了值不能变，没有其它区别。</p><h4 id="修饰成员变量" tabindex="-1"><a class="header-anchor" href="#修饰成员变量" aria-hidden="true">#</a> 修饰成员变量</h4><p>final修饰成员变量表示该成员变量变成了一个常量，它在内存中的位置，生命周期，使用方式等都不会改变。</p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">final</span> 数据类型 变量名<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果直接在类中成员位置，写上述语法定义成员&quot;常量&quot;，肯定会报错。这是因为默认值不能当成final修饰成员变量的取值，必须 <span style="color:red;background:yellow;"><strong>（在创建对象过程中）</strong></span>显式明确的给出一个值，而且这个值一旦给出就不可更改了。也就是说， <span style="color:red;background:yellow;"><strong>成员常量的赋值，有且必须有一次。</strong></span>目前我们给成员变量的赋值方式还有（除了默认初始化）：</p><ol><li>显式赋值</li><li>构造代码块赋值</li><li>构造器赋值</li></ol><p><strong>以上三种方式，选择其一即可，而且也必须，也只能选择其一。其它对象创建完毕后的赋值方式都不行。</strong></p><p>注：如果依赖构造器赋值，必须保证类的每个构造器都能完成成员变量的赋值，否则会编译报错。（想一想为什么？）</p><p>下列代码就是不正确的，因为如果无参创建对象，age这个常量就没值。</p><p>构造器赋值final成员常量</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>最后思考： <strong>成员&quot;常量&quot;是不是真正意义上的常量?</strong><br> 不是，因为成员&quot;常量&quot;属于对象，每个对象可能都有自身的常量取值，完全可能不同，而真正意义上的常量，像Math.PI(圆周率)这种，是肯定不会因为创建对象而产生不同的。所以实际开发中，成员常量是很少见的。</p><!----><h4 id="修饰静态成员变量" tabindex="-1"><a class="header-anchor" href="#修饰静态成员变量" aria-hidden="true">#</a> 修饰静态成员变量</h4><p>final修饰静态成员变量表示一个静态的&quot;常量&quot;，在<span style="color:red;background:yellow;"><strong>类的全局仅有一份</strong></span>，所以final修饰静态成员变量，也称之为<!---->。它是一个真正意义上的常量，不会因为创建对象而更改，实际开发中的常量多使用它。</p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">static</span> <span class="token keyword">final</span> 数据类型 变量名<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>和final修饰成员变量一样，全局常量的取值也不能依赖于默认值，必须 <span style="color:red;background:yellow;"><strong>（在类加载过程中）</strong></span>明确一个值。这样静态成员变量的赋值方式还有（除去默认初始化）：</p><ol><li>显式赋值</li><li>静态代码块</li></ol><p><strong>以上两种赋值方式，必须且只能选择其一。其他的赋值方式，比如在创建对象过程中的赋值方式，都是不可以的</strong></p><hr><p>注意：</p><ol><li>final static 还是 static final 实测下来，都是可以的，根据个人习惯使用即可。</li><li>final修饰静态成员变量是一个全局常量，不会害怕外界访问和修改。所以在很多时候，它的访问权限修饰符都是public的。</li><li>如果使用静态代码测试类加载，那么访问类的全局常量，有些场景是不完整的类加载的, 不是完整的类加载,静态代码块没有执行。（感兴趣自己测试一下，作为锻炼动手能力的小demo）</li></ol><h4 id="修饰引用数类型" tabindex="-1"><a class="header-anchor" href="#修饰引用数类型" aria-hidden="true">#</a> 修饰引用数类型</h4><p>前面已经提到过了，final修饰引用数据类型的变量，表示引用不能指向新的对象， 但是对象的状态是可以被改变的。</p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> 类名 对象名 <span class="token operator">=</span> <span class="token keyword">new</span> 类名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注：final只能修饰引用，所以它不能去修饰匿名对象。下面代码是不允许的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="练习-2" tabindex="-1"><a class="header-anchor" href="#练习-2" aria-hidden="true">#</a> 练习</h3><ol><li><p>读程序，回答注释问题。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span> num1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">byte</span> num2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">byte</span> num3 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">byte</span> num4 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword">byte</span> result<span class="token punctuation">;</span>
  	<span class="token comment">// 下列代码哪行能通过编译，哪行不能？</span>
    result <span class="token operator">=</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span> <span class="token comment">// 转换位 byte</span>
    result <span class="token operator">=</span> num3 <span class="token operator">+</span> num4<span class="token punctuation">;</span><span class="token comment">// 可以</span>
    result <span class="token operator">=</span> num1 <span class="token operator">+</span> num3<span class="token punctuation">;</span><span class="token comment">// 不能</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>注释中的两行代码，哪一行能正常运行？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//return a++;</span>
    <span class="token comment">//return a+1;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>注释中的两行代码，哪一行能正常运行？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">final</span> <span class="token class-name">Student</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// s = new Student();</span>
       <span class="token comment">// s.age = 18;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h1 id="多态-1" tabindex="-1"><a class="header-anchor" href="#多态-1" aria-hidden="true">#</a> 多态</h1><p>学习目标:</p><ul><li>掌握多态的定义</li><li>掌握多态的使用</li><li>了解多态的优缺点</li><li>掌握引用数据类型的类型转换</li><li>掌握instanceof关键字</li></ul><h2 id="概述-2" tabindex="-1"><a class="header-anchor" href="#概述-2" aria-hidden="true">#</a> 概述</h2><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3><blockquote><p>什么是多态（<strong>polymorphic</strong>）呢？</p></blockquote><p>从字面意义上理解，同一个事物，在不同的时刻/情况表现出不同的状态，就可以称之为多态。</p><p>在Java的多态当中，多态指的是：</p><ol><li>同一种事物：同一个引用（即父类的引用）</li><li>不同的情况：指向不同的对象（不同的子类对象）</li><li>不同的状态：调用同名方法会体现出不同的行为</li></ol><p>总结来说，Java中的多态指的是，同一个父类引用指向不同子类对象时，调用同名成员方法，根据指向实际对象的不同，得到的行为也会随之不不同。</p><p>练习:</p><p>定义一个父类Phone, 3个子类Huawei, XiaoMi, Iphone去模拟多态场景.</p><h3 id="多态的发生条件" tabindex="-1"><a class="header-anchor" href="#多态的发生条件" aria-hidden="true">#</a> 多态的发生条件</h3><p>根据上述定义，总结一下Java中多态发生的条件：</p><ol><li>必须存在继承，多态一定发生在父子类之间。</li><li>必须存在方法重写，不同的子类需要重写父类中的同名方法。</li><li>必须存在父类引用指向子类对象</li></ol><h3 id="不能发生多态的场景" tabindex="-1"><a class="header-anchor" href="#不能发生多态的场景" aria-hidden="true">#</a> 不能发生多态的场景</h3><p>将上述条件反转一下，自然就得到了不能发生多态的场景：</p><ol><li>不能继承的类，即final修饰的类。一个final修饰的类都没有子类，多态肯定和它无缘。</li><li>不能重写的方法，不能重写也没有多态。不能重写的方法有： <ol><li>final修饰的方法，final限制了重写</li><li>static方法，不参与继承和重写。</li><li>private方法，没有权限重写。</li><li>构造方法，不能继承。</li></ol></li><li>不写代码用父类引用指向子类对象，同样没有多态。（这一点就需要手动完成了，看程序员用不用）</li></ol><h2 id="多态的访问特征" tabindex="-1"><a class="header-anchor" href="#多态的访问特征" aria-hidden="true">#</a> 多态的访问特征</h2><p><span style="color:red;background:yellow;"><strong>当父子类出现同名成员（变量或方法）时，使用多态的形式访问（多态的形式指：用父类引用指向子类对象，然后用引用名访问成员）时的访问特征。</strong></span></p><h3 id="成员变量" tabindex="-1"><a class="header-anchor" href="#成员变量" aria-hidden="true">#</a> 成员变量</h3><!----><p>用一句话来总结，对象名点成员变量的访问特征：</p><blockquote><p><span style="color:red;background:yellow;"><strong>编译时（访问范围）看左边，运行时（访问结果）还看左边。</strong></span></p></blockquote><p>成员变量描述的是对象的属性或者外貌特征，把子类对象赋值给父类的引用，就相当于给子类对象披上了一个父类类型马甲。这样在外界看来，这时候的子类就变成了父类。总之，还是这句话：编译时看左边，运行时看左边。</p><h3 id="成员方法" tabindex="-1"><a class="header-anchor" href="#成员方法" aria-hidden="true">#</a> 成员方法</h3><p>多个子类同时重写了父类中的一个方法，并出现父类引用指向不同子类对象，并且用对象名点调用同名方法时，方法的调用结果就体现出多态的特点。</p><p>用一句话来总结，对象名点成员方法的访问特征：</p><blockquote><p><span style="color:red;background:yellow;"><strong>编译（访问范围）看左边，运行时（调用结果）看右边。</strong></span></p></blockquote><p>电视机的案例，就很适合来解释方法调用的多态性。</p><blockquote><p>我去商场买了一台一万多的小米智能电视机，功能十分丰富，很强大。</p><p>对于这台电视机而言，我需要使用遥控器才能操控，换句话说，只有遥控器上提供的功能我们才能使用。</p><ul><li>假如电视机上仅有开关机按键，那我们就只能做开关机的操作。</li><li>即便是电视机本身功能再丰富，没有遥控器的支持，我们也做不了什么。</li></ul><p><strong>将这个案例转移到Java中 &gt;&gt;&gt;&gt;&gt;&gt; 子类对象就是一台功能强大的电视机，父类引用就是功能受限的遥控器</strong></p><p>子类对象本身可能是十分强大，但父类引用中没有的方法也访问不到（父类引用限制了子类对象的方法访问范围）</p><p>但是即便是一个只有开关机的遥控器，小米智能电视机的开关机也做得足够炫酷。 这就是具体方法的实现，要看具体对象的类型。</p></blockquote><!----><h2 id="多态的优缺点" tabindex="-1"><a class="header-anchor" href="#多态的优缺点" aria-hidden="true">#</a> 多态的优缺点</h2><p>我们通过一个案例来理解多态的优缺点：</p><blockquote><p>科学家要收集动物的叫声去研究，先要收集猫，狗两种动物的叫声研究。随后又扩展到其它动物，最后又需要研究人类。</p></blockquote><p>我们可以先定义一个顶层父类Animal作为父类，然后定义具体动物类：猫和狗。</p><p>假如收集每种动物的叫声研究，都需要写一个方法，显然过于麻烦，程序扩展性也太差了。所以我们可以这么做：</p><ol><li>写一个方法来收集研究动物的叫声，方法的形参不写具体动物类，而写顶层祖先类：Animal。然后在方法体中，调用叫的方法即可。</li><li>这样该方法在调用传参时，就可以Animal不同的子类对象了。这仍然是一个父类引用指向子类对象</li></ol><p>这就是多态一个基本的使用案例，当传入方法不同的子类对象时，方法执行时就会根据不同的具体对象类型，来决定行为。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><p>从这个案例，我们其实就可以大致总结多态的优点了：</p><ol><li>要实现多态必须要继承，而继承提高了代码复用率，提升了程序的可维护性。（继承保证）</li><li>有了多态后，用父类引用指向不同子类对象，只需要调用同名方法，就能自动根据不同子类对象，得出不同的行为。这大幅度简化了代码，提升了程序的扩展性。（多态保证）</li></ol><blockquote><p>这里讲一个形象的案例：</p><p>假如你做一个游戏，游戏中有很多角色，角色们都能释放技能，但技能各不相同。如果没有多态，那就必须逐一调用方法来释放不同的技能，但是有了多态只需要调用技能完事，程序会自动根据不同的角色对象，释放出不同的技能。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 没有多态时：	</span>
角色<span class="token number">1</span>引用<span class="token punctuation">.</span>技能<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
角色<span class="token number">2</span>引用<span class="token punctuation">.</span>技能<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
角色<span class="token number">3</span>引用<span class="token punctuation">.</span>技能<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
角色<span class="token number">4</span>引用<span class="token punctuation">.</span>技能<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 有了多态后：</span>
角色父类引用<span class="token punctuation">.</span>技能<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><p>多态肯定是有缺点的，而且很明显。由于多态中，使用父类引用指向子类对象，父类引用限制了子类对象的功能，这意味着：</p><ul><li>子类独有的成员是无法使用父类引用访问的。</li></ul><p><strong>而一旦你必须在这时候访问子类独有成员的话，这就需要把父类类型引用，再转换回子类类型的引用，从继承的方向上，这是从上到下的，称之为&quot;向下转型&quot;。之前我们讲过，这属于强制类型转换。</strong></p><p>但是强转十分危险，稍有不慎就会导致程序异常，下面我们详细分析引用数据类型的强制类型转换。</p><h2 id="引用数据类型的强制类型转换" tabindex="-1"><a class="header-anchor" href="#引用数据类型的强制类型转换" aria-hidden="true">#</a> 引用数据类型的强制类型转换</h2><p><strong>思考：</strong><br><strong>方法的实参数据类型，需要和方法的形参数据类型保持一致吗？</strong></p><p>不需要，存在数据类型的自动类型转换</p><ul><li>在学习基本数据类型参数时： <ul><li>如果方法的实参数据类型,可以自动类型转换到形参数据类型</li><li>那么该实参变量就允许传入方法</li></ul></li><li>将上述原则扩展到引用数据类型参数，也是可以的： <ul><li>如果方法的实参传入的对象，可以向上转型到形参数据类型, 那么该实参对象就允许传入方法</li><li>如果方法的形参数据类型是一个父类类型，那么也允许传入它的子类对象</li><li>方法的传参可以向上转型，方法的返回值类型也是可以的</li></ul></li></ul><p>父类的引用转换成子类的引用，在继承链中属于向下，属于&quot;向下转型&quot;。编译器默认不允许，需要显式地写代码完成类型转换。</p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>子类类名 对象名 <span class="token operator">=</span> （子类类名）父类引用<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当然上述语法不是乱写地，向下转型是有条件的。</p><h3 id="前提" tabindex="-1"><a class="header-anchor" href="#前提" aria-hidden="true">#</a> 前提</h3><p><strong>发生的前提:</strong></p><ul><li>必须将父类引用转换成它的子类引用，如果不是转换成它的子类引用，会编译报错。</li></ul><p><strong>成功的前提:</strong></p><ul><li>强转后的引用类型必须能够真正的指向该对象, 即强转后的引用的类型必须是该对象的类型或者其父类型</li></ul><p><strong>解释说明:</strong></p><ul><li><p>父类引用指向的真实对象的类型，就是要强转成的子类类型的对象。</p><ol><li><p>比如我先做了一次自动转换，这时父类引用fs指向的实际对象就是Son子类对象</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Father</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>那么做强转，将fs引用，强转回Son类的引用，是完全可以的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Son</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Son</span><span class="token punctuation">)</span>fs<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>这种强转的形式还是比较好理解的，本质上其实是一次&quot;物归原主&quot;，Son对象本身就该是Son引用指向的，强转回去就不会出错。</p></li><li><p>假如Father还有一个子类Son2，那么将fs强转成Son2引用，虽然编译不会报错，但运行一定会出错。</p></li></ol></li><li><p>父类引用指向的真实对象的类型，就是要强转成的子类类型的子类对象。</p><ol><li><p>先假设有一个三层的继承体系：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Grandson</span> <span class="token keyword">extends</span> <span class="token class-name">Son</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>然后做一次自动类型转换，这时父类引用其实指向的是&quot;孙子类&quot;对象。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Father</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Grandson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>那么做强转就有了两个选项，其中将fs强转成Son引用，就符合父类引用指向的真实对象的类型，就是要强转成的子类类型的子类对象。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Son</span> fs1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Son</span><span class="token punctuation">)</span> fs<span class="token punctuation">;</span>
<span class="token class-name">Grandson</span> fs2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Grandson</span><span class="token punctuation">)</span> fs<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>这种场景实际开发中，不多见，但也要知道。</p></li></ol></li></ul><hr><p>如果看完上面的，你还似懂非懂，那就看下图再去理解一下：</p><img src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201101203334.png?align=center" alt="向下转型成功前提" style="zoom:25%;"><!----><ul><li>Grandson对象有三个引用都可以指向它，Father、Son、Grandson</li><li>那么假如Father引用指向它时，父类引用Father就可以强转为Son或者Grandson引用。</li><li>Son对象有两个引用可以指向它，Son、Father</li><li>那么假如Father引用指向它时，父类引用Father就可以强转为Son</li></ul><p><strong>所以强转能够成功的前提条件是：引用所指向的真实对象，必须是强转后的引用能够指向的对象。所以可以是强转后的引用的类型的对象或者子类对象</strong></p><h3 id="instanceof关键字" tabindex="-1"><a class="header-anchor" href="#instanceof关键字" aria-hidden="true">#</a> instanceof关键字</h3><p><code>向下转型</code>是一种强转，它成功的条件相对比较苛刻。在操作之前，要先慎重考虑。</p><p>强转失败会导致程序抛出异常：<code>ClassCastException</code>，导致程序终止执行。正是由于强转的条件苛刻，而且失败后果很严重，所以Java当中提供了检测手段，来保障强转的安全性。需要使用关键字： <span style="color:red;background:yellow;"><strong>instanceof</strong></span></p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>引用名 <span class="token keyword">instanceof</span> 类名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述语法返回一个boolean类型值：</p><ol><li><span style="color:red;background:yellow;"><strong>true表示该引用指向的对象，是后面类名的一个对象或者子类对象。</strong></span></li><li>反之，false则表示不是。</li><li><span style="color:red;background:yellow;"><strong>当引用指向null时，使用该语法，结果会直接返回false。</strong></span></li></ol><p>显然，无论引用指向的对象，是后面类名的对象还是子类对象，都符合强转成功的条件。普遍情况下，可以直接将上述语法直接写在if判断中，判断结果是true后，就可以放心大胆做强转处理了。</p><h3 id="总结-3" tabindex="-1"><a class="header-anchor" href="#总结-3" aria-hidden="true">#</a> 总结</h3><p>引用数据类型要成功&quot;向下转型&quot;，完成强转条件是很苛刻的，实际开发中，先慎重考虑是否真的需要强转。然后在做强转之前，也需要使用<code>instanceof</code>关键字判断，保障安全性。麻痹大意，导致抛出<code>ClassCastException</code>异常，就会很难受了。</p><h2 id="多态练习" tabindex="-1"><a class="header-anchor" href="#多态练习" aria-hidden="true">#</a> 多态练习</h2><p>1.看代码，说出执行结果</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Father</span> cf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cf<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//48</span>
        cf<span class="token punctuation">.</span><span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//论语</span>
        <span class="token comment">//cf.playGame(); 不能打游戏，因为父类没这个成员</span>
        <span class="token class-name">Son</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Son</span><span class="token punctuation">)</span> cf<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//28</span>
        c<span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">48</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我要教Java&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;孔子喜欢玩大乱斗！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我会教论语&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大家课下看看，琢磨琢磨语法也就差不多了，不用深入考究。</p><p>2.看代码，说出执行结果</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Father</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//System.out.println(f.aa); 父类中没有aa</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;----------------&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Son</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>aa<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;----------------&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//f.testSon(); 父类中没有该方法</span>
        f<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        f<span class="token punctuation">.</span><span class="token function">testFather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;----------------&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span><span class="token function">testSon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span><span class="token function">testFather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Father&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFather</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Only Father&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> aa <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Son&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Only Son&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/LSauce/JavaFarms/edit/main/src/Java/SE/5_面向对象三大特征.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a aria-label="04.面向对象基础" class="vp-link nav-link prev nav-link prev" href="/Java/SE/4_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>04.面向对象基础</div></a><a aria-label="06.面向对象设计" class="vp-link nav-link next nav-link next" href="/Java/SE/6_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">06.面向对象设计<span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper"><!----><div class="vp-copyright">Copyright © 2023 JavaFarmer</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-58d2c58f.js" defer></script>
  </body>
</html>
