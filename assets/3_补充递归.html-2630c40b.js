import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c,b as s,d as n,e as l,f as a}from"./app-58d2c58f.js";const i={},u=a(`<h1 id="递归的定义" tabindex="-1"><a class="header-anchor" href="#递归的定义" aria-hidden="true">#</a> 递归的定义</h1><p>我们已经学习过方法，使用过方法了。方法体中是可以调用方法的，那么如果在方法体中调用方法自身呢？</p><p>特别的，在一个方法当中再次调用这个方法，就像故事里提到同样的故事一样，<strong>我们把方法在运行时调用自身的情况，称之为递归，又叫做递归调用。</strong></p><h1 id="使用递归的注意事项" tabindex="-1"><a class="header-anchor" href="#使用递归的注意事项" aria-hidden="true">#</a> 使用递归的注意事项</h1><p>递归的使用有很多限制，尤其要注意以下两点：</p><ol><li>合法的递归，除了要有递归体语句外，还要有递归出口。无限制的递归下去，会引发栈溢出错误（StackOverflowError）</li><li>即便是有出口的递归，递归的深度也不能超过栈空间的大小，否则仍然会报错</li></ol><p>案例1: 自然数求和</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 递归出口</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> n<span class="token operator">+</span><span class="token function">sum</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="递归栈溢出问题" tabindex="-1"><a class="header-anchor" href="#递归栈溢出问题" aria-hidden="true">#</a> 递归栈溢出问题</h1><p>递归是方法自我调用的过程，但是**&quot;只递不归&quot;**的<code>套娃</code>会导致程序崩溃，报错递归栈溢出错误（StackOverflowError），是一个错误（Error），是比Exception要更加的严重的错误。</p><p>产生栈溢出错误的原因在于：</p><ol><li>Java程序运行时，调用方法是有代价的：要占用栈（stack）中的内存空间</li><li>方法执行结束后，方法出栈，释放内存，所以一般情况下，栈内存不会溢出，始终够用</li><li>无限制的递归调用方法，会导致方法只进栈不出栈，很快栈内存空间就不够用了</li><li>这种情况就是&quot;栈溢出错误&quot;，对程序而言是致命错误，程序必须停止执行。</li></ol>`,12),r={href:"http://StackOverflow.com",target:"_blank",rel:"noopener noreferrer"},k=a(`<p>百度 , CSDN(可能有错) , 掘金, V2ex , google , 知乎</p><h1 id="递归的思想与危险的递归" tabindex="-1"><a class="header-anchor" href="#递归的思想与危险的递归" aria-hidden="true">#</a> 递归的思想与危险的递归</h1><p>案例2：使用递归计算N（N&gt;=1）的阶乘**（factorial）**</p><p>这个代码很好写，参考如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//求n的阶乘</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">//建议写递归先写递归出口</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以总结一下使用递归的两要素：</p><ol><li>递归体（方法中自身调用自身方法的那句语句）</li><li>递归出口</li></ol><p>以上两部分对于一个正常的递归而言都是必须的，在实际使用中，我们只要找到这两个部分就能够写出递归的代码了。</p><p>观察这样的一个代码，我们想求n的阶乘，就只需要知道（n - 1）的阶乘的值，（n - 1）阶乘的结果就需要知道（n - 2）阶乘的结果，最终我们知道1的阶乘就是1。</p><p><strong>这种将大问题分解为小问题的思想就是递归的思想：</strong></p><ol><li>把一个复杂的大规模的问题，分解成若干相似的小规模的子问题。</li><li>当子问题规模足够小的时候，就可以直接得到小规模问题的解。</li><li>然后把所有的小规模的子问题的解，组合起来，得到要求解的大规模问题的解。</li></ol><hr><p>对比一下，下面没有使用递归，正常使用for循环的代码：</p><p>循环求n的阶乘</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">factorial2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// n! = n * (n-1) * (n-2) * ...* 1</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// temp的值会逐渐变小,只要还大于0就要一直乘下去</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result <span class="token operator">*=</span> temp<span class="token punctuation">;</span>
        temp<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不难发现递归的优点是：</p><ol><li>递归的代码会非常简洁，这是最直观的。</li><li>人在解决问题的时候，都会下意识的分解问题。递归的思想很符合人的思维，用递归求解一个问题的思路很容易被人理解。</li><li>接第二条，一旦能够找打分解问题的思路，递归会非常好用。</li></ol><p>当然递归的缺点也非常明显：</p><ol><li>不用递归时，往往一个方法就能解决问题。而递归会调用多个方法，占用大量栈内存，且明显存在重复计算，效率低。也就是说，<strong>使用递归求解一个问题，时间和空间复杂度都不占优势，既占用空间效率还低。</strong></li><li>栈溢出错误警告！递归很危险，一旦栈溢出是严重错误！</li></ol><hr><p>综上，递归是一把伤人亦伤己的利器，实际开发中不要随意使用递归，使用递归要深思熟虑递归的深度和出口，避免栈溢出错误</p><h1 id="经典案例" tabindex="-1"><a class="header-anchor" href="#经典案例" aria-hidden="true">#</a> 经典案例</h1><p>斐波那契(Feibonacci)数列</p><p>1, 1 , 2 , 3 , 5 , 8 , 13 , 21.....</p><p>求第n个位置的值是多少</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">faibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 递归出口</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token function">faibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">faibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>青蛙跳台阶<br> 一只青蛙一次可以跳上一层台阶，也可以跳上两层，<br> 求该青蛙跳上n层的台阶总共有多少种跳法（先后次序不同算不同的结果)</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">jumpStep</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">jumpStep</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">jumpStep</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,28);function d(v,m){const e=t("ExternalLinkIcon");return o(),c("div",null,[u,s("p",null,[n("热知识："),s("a",r,[n("StackOverflow.com"),l(e)]),n(" 是全球最大的程序员问答平台。")]),k])}const f=p(i,[["render",d],["__file","3_补充递归.html.vue"]]);export{f as default};
