const t=JSON.parse('{"key":"v-c0994d8e","path":"/Java/SE/3_%E8%A1%A5%E5%85%85%E9%80%92%E5%BD%92.html","title":"03.补充递归","lang":"zh-CN","frontmatter":{"title":"03.补充递归","index":true,"icon":"laptop-code","category":["JavaSE"],"description":"我们已经学习过方法，使用过方法了。方法体中是可以调用方法的，那么如果在方法体中调用方法自身呢？ 特别的，在一个方法当中再次调用这个方法，就像故事里提到同样的故事一样，我们把方法在运行时调用自身的情况，称之为递归，又叫做递归调用。 递归的使用有很多限制，尤其要注意以下两点： 1. 合法的递归，除了要有递归体语句外，还要有递归出口。无限制的递归下去，会引发...","head":[["meta",{"property":"og:url","content":"https://jf.kiroe.cn/Java/SE/3_%E8%A1%A5%E5%85%85%E9%80%92%E5%BD%92.html"}],["meta",{"property":"og:site_name","content":"JavaFarms"}],["meta",{"property":"og:title","content":"03.补充递归"}],["meta",{"property":"og:description","content":"我们已经学习过方法，使用过方法了。方法体中是可以调用方法的，那么如果在方法体中调用方法自身呢？ 特别的，在一个方法当中再次调用这个方法，就像故事里提到同样的故事一样，我们把方法在运行时调用自身的情况，称之为递归，又叫做递归调用。 递归的使用有很多限制，尤其要注意以下两点： 1. 合法的递归，除了要有递归体语句外，还要有递归出口。无限制的递归下去，会引发..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"JavaFarmer"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"03.补充递归\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JavaFarmer\\",\\"url\\":\\"https://jf.kiroe.cn\\"}]}"]]},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.37,"words":1311},"filePathRelative":"Java/SE/3_补充递归.md","autoDesc":true}');export{t as data};
