import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as e,f as r}from"./app-58d2c58f.js";const t="/assets/image-20221025101040480-4cf87134.png",n="/assets/image-20221025114142799-3a029296.png",s="/assets/image-20230223210058412-af9ea24a.png",g="/assets/image-20221025111136554-d2a6313b.png",o="/assets/image-20221025111147963-9b8222ee.png",d="/assets/image-20221025111805455-3919a0db.png",c="/assets/image-20221025111757163-7ada37fc.png",h="/assets/image-20221025112108481-05044193.png",p="/assets/image-20221025113059119-314f326b.png",l={},m=r('<h1 id="jvm运行时数据区" tabindex="-1"><a class="header-anchor" href="#jvm运行时数据区" aria-hidden="true">#</a> JVM运行时数据区</h1><figure><img src="'+t+'" alt="image-20221025101040480" tabindex="0" loading="lazy"><figcaption>image-20221025101040480</figcaption></figure><p><strong>程序计数器</strong><br> 程序计数器（Program Counter Register）是一块较小的内 存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。(<strong>每个线程都有自己的程序计数器，线程隔离</strong>)</p><p><strong>Java虚拟机栈</strong><br> 它描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame ）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>线程私有(线程隔离)</strong></p><p><strong>本地方法栈(线程私有)</strong><br> 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。</p><p><strong>Java堆</strong><br> 此内存区域的唯一目的就是存放对象，一个JVM实例只存在一个堆，堆内存的大小是可以调节的.<strong>堆内存是线程共享的</strong>。totalMemory 默认是系统64分之一 250M maxMemory 默认是系统的四分之一 4g</p><p>-Xms200m -Xmx300m</p><p><strong>方法区(线程共享)</strong><br> 方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量 、静态变量等数据。</p><p>方法区是逻辑概念</p><ul><li>永久代</li><li>元空间</li></ul><figure><img src="'+n+'" alt="image-20221025114142799" tabindex="0" loading="lazy"><figcaption>image-20221025114142799</figcaption></figure><h1 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理" aria-hidden="true">#</a> 内存管理</h1><p><strong>显式的内存管理(C/C++)</strong><br> 内存管理(内存的申请和释放)是程序开发者的职责 malloc() free()<br> 常见问题：<br> 内存泄漏：内存空间已经申请，使用完毕后未主动释放<br> 野指针：使用了一个指针，但是该指针指向的内存空间 已经被free<br><strong>隐式的内存管理(Java/C#)</strong><br> 内存的管理是由垃圾回收器自动管理的<br> 优点：增加了程序的可靠性，减小了memory leak<br> 缺点：无法控制GC的时间，耗费系统性能</p><h1 id="gc" tabindex="-1"><a class="header-anchor" href="#gc" aria-hidden="true">#</a> GC</h1><h2 id="如何确定垃圾" tabindex="-1"><a class="header-anchor" href="#如何确定垃圾" aria-hidden="true">#</a> 如何确定垃圾</h2><h3 id="引用计数算法" tabindex="-1"><a class="header-anchor" href="#引用计数算法" aria-hidden="true">#</a> 引用计数算法</h3><p>确定哪些对象已经变成了垃圾，最简单的算法就是引用计数法<br> 给对象添加一个引用计数器<br> 每当一个地方引用它时，计数器加1<br> 每当引用失效时，计数器减少1<br> 当计数器的数值为0时，也就是对象无法被引用时，表明对象不可在使用</p><p>但是这个算法存在一个致命的缺陷，无法解决循环引用的问题</p><p>为此，引入了另外一种根搜索算法。</p><h3 id="根搜索算法" tabindex="-1"><a class="header-anchor" href="#根搜索算法" aria-hidden="true">#</a> 根搜索算法</h3><p>这个算法的基本思想是将一系列称为“GC Roots”的对象作为起始点<br> 从这些节点开始向下搜索<br> 搜索所走的路径称为引用链<br> 当一个对象到所有的GC root之间没有任何引用链相连，时，就认为该对象变成了垃圾</p><figure><img src="'+s+'" alt="image-20230223210058412" tabindex="0" loading="lazy"><figcaption>image-20230223210058412</figcaption></figure><p>GC Roots包含对象呢？<br> 虚拟机栈中引用的对象<br> 方法区中的静态属性引用的对象</p><h2 id="如何回收垃圾" tabindex="-1"><a class="header-anchor" href="#如何回收垃圾" aria-hidden="true">#</a> 如何回收垃圾</h2><h3 id="标记清除算法" tabindex="-1"><a class="header-anchor" href="#标记清除算法" aria-hidden="true">#</a> 标记清除算法</h3><figure><img src="'+g+'" alt="image-20221025111136554" tabindex="0" loading="lazy"><figcaption>image-20221025111136554</figcaption></figure><figure><img src="'+o+'" alt="image-20221025111147963" tabindex="0" loading="lazy"><figcaption>image-20221025111147963</figcaption></figure><h3 id="标记复制算法" tabindex="-1"><a class="header-anchor" href="#标记复制算法" aria-hidden="true">#</a> 标记复制算法</h3><figure><img src="'+d+'" alt="image-20221025111805455" tabindex="0" loading="lazy"><figcaption>image-20221025111805455</figcaption></figure><figure><img src="'+c+'" alt="image-20221025111757163" tabindex="0" loading="lazy"><figcaption>image-20221025111757163</figcaption></figure><h3 id="标记整理算法" tabindex="-1"><a class="header-anchor" href="#标记整理算法" aria-hidden="true">#</a> 标记整理算法</h3><figure><img src="'+h+'" alt="image-20221025112108481" tabindex="0" loading="lazy"><figcaption>image-20221025112108481</figcaption></figure><h3 id="分代收集算法" tabindex="-1"><a class="header-anchor" href="#分代收集算法" aria-hidden="true">#</a> 分代收集算法</h3><figure><img src="'+p+'" alt="image-20221025113059119" tabindex="0" loading="lazy"><figcaption>image-20221025113059119</figcaption></figure><p><strong>2个假说</strong></p><ul><li>强分代假说 <ul><li>熬过越多次垃圾收集过程的对象就越难以消亡。(简单理解就是越老的对象就具有”老而不死”的特性)</li></ul></li><li>弱分代假说 <ul><li>弱分代假说（Weak Generational Hypothesis）: 绝大多数对象都是朝生夕灭的.</li></ul></li></ul><h2 id="什么时候回收垃圾" tabindex="-1"><a class="header-anchor" href="#什么时候回收垃圾" aria-hidden="true">#</a> 什么时候回收垃圾</h2><p>申请heap space失败后会触发GC回收</p><p>系统进入idle后一段时间会进行回收</p><p>主动调用GC进行回收 System.gc()</p>',40),f=[m];function b(u,_){return i(),e("div",null,f)}const C=a(l,[["render",b],["__file","17_GC.html.vue"]]);export{C as default};
