import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as i,c,b as n,d as a,e as t,w as e,f as l}from"./app-58d2c58f.js";const u={},d=l('<p><strong>学习目标</strong></p><ul><li>掌握方法的定义与使用</li><li>掌握方法的重载</li></ul><h1 id="方法概述" tabindex="-1"><a class="header-anchor" href="#方法概述" aria-hidden="true">#</a> 方法概述</h1><h2 id="引入" tabindex="-1"><a class="header-anchor" href="#引入" aria-hidden="true">#</a> 引入</h2><p>引例，现在有三个需求：</p><ol><li>编写程序，计算10+20，并输出结果</li><li>编写程序，计算111+222，并输出结果</li><li>编写程序，计算333+444，并输出结果</li></ol><p>请问这个程序有哪些缺点呢？</p><p>很明显：</p><p>这个程序中有大量的代码是重复的，是可以被<span style="color:red;background:yellow;"><strong>复用</strong></span>的，是可以优化的。</p>',9),r=n("strong",null,"方法",-1),k=n("ol",null,[n("li",null,"能够重复实现某种特定功能，解决同一类问题，而不需要重复写代码。"),n("li",null,"每次实现这个功能时，可以传入不同的数据。"),n("li",null,"传入数据实现功能后，能够得到不同的结果。")],-1),v=n("p",null,[a("核心需求就是，"),n("strong",null,"能复用代码，有输入和输出。")],-1),m=n("strong",null,"方法",-1),b=n("strong",null,"方法的调用（invoke）。",-1),h=l(`<p>方法实际上是可以重复完成特定功能的代码块，<strong>本质是为了代码复用。</strong></p><h2 id="方法的基本使用" tabindex="-1"><a class="header-anchor" href="#方法的基本使用" aria-hidden="true">#</a> 方法的基本使用</h2><h3 id="方法的定义" tabindex="-1"><a class="header-anchor" href="#方法的定义" aria-hidden="true">#</a> 方法的定义</h3><p>一般情况下，定义一个方法是以下语法结构：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>修饰符列表<span class="token punctuation">]</span> 返回值类型 方法名 <span class="token punctuation">(</span>形式参数列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// 方法体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在具体了解每个部分的语义之前，我们需要了解 两个非常重要的概念：</p><ol><li>方法的声明(方法头): [修饰符列表] 返回值类型 方法名 (形式参数列表)</li><li>方法的签名: 方法名 (形式参数列表)</li></ol><p>接下来逐一解释语法的每个部分：</p><ol><li>修饰符列表：修饰符列表不是必须的，可以为空不写，现在默认为public static（具体含义面向对象讲）</li><li>返回值类型：方法可能会有结果，这个结果就是返回值，返回值的数据类型称之为返回值类型 <ol><li>返回值类型可以是基本数据类型，也可以是引用数据类型（例如String） <ul><li>此时表示方法拥有返回值，必须显式的指出该返回值，否则编译报错</li><li>在方法体中用return关键字指示返回值，格式为return + 返回值</li><li>return后的返回值的数据类型，要和方法声明中的返回值类型保持一致（或者兼容）</li><li>方法执行到return语句时，表示方法执行完毕。</li></ul></li><li>方法完全可以没有结果，也就是没有返回值，但是方法必须要有返回值类型，用关键字void标记。使用void标记的方法，没有返回值，自然也无需指出返回值</li></ol></li><li>方法名：给方法起个名字，调用方法时用的，方法名的命名需要遵守规范 <ul><li>必须是合法的标识符</li><li>方法名最好见名知意</li><li>小驼峰命名法</li></ul></li><li>形式参数列表：方法在实现功能时，有时需要传入数据。方法在定义时就应该告诉方法的调用者应该传入什么数据，这就是形式参数列表，简称形参列表 <ul><li>形参可以是基本数据类型变量，也可以是引用数据类型变量</li><li>形参的个数不受限，多个形参之间用逗号隔开</li><li>形参的作用域仅在方法内部，它们都是局部变量</li><li>形参中起关键决定性作用的是形参的数据类型，形参名只是一个标识符，不会影响方法调用</li><li>调用方法时传入的具体数据参数称之为实际参数，简称实参</li><li>方法调用时，实参和形参的数据类型要一一对应，并且保持一致（或者兼容）</li></ul></li><li>方法体：方法体包含具体的语句，定义该方法的功能，由大括号包裹起来。</li></ol><p>特别注意 ：</p><p>一定要分清楚，什么是形式参数和实际参数。形参完全可以理解成一个占位符，它的作用只是告诉方法的调用者，该传入什么类型的参数。而方法的实参才是一个真正的参数。</p><h3 id="方法的调用" tabindex="-1"><a class="header-anchor" href="#方法的调用" aria-hidden="true">#</a> 方法的调用</h3><p>明确上述语法后，定义完方法后。接下来需要调用方法，使方法生效：</p><ol><li><p>在Java当中，main方法是程序的入口方法，一个方法必须直接或间接地在main方法中调用才会被执行。</p></li><li><p>对于修饰符列表中有static的方法，在同一个class的main方法中的调用方式是：方法名(实际参数列表)</p><blockquote><p>注：实际上，同一个类中的static方法之间，都可以使用这种方式直接互相调用。</p></blockquote></li><li><p>调用一个有返回值的方法，实际上就是操作返回值，void方法没有返回值，不能做任何操作。</p></li></ol><p>但是要注意：</p>`,15),g=l(`<p>Demo:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Result of &#39;NewDemo.sum()&#39; is ignored</span>
    <span class="token comment">// 方法既然有返回值,那么建议去接收或者使用这个返回值</span>
    <span class="token keyword">int</span> sumValue <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sumValue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token comment">// 操作方法调用就是操作方法的返回值</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 定义一个方法,来完成求两个int类型数值的和</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用细节" tabindex="-1"><a class="header-anchor" href="#使用细节" aria-hidden="true">#</a> 使用细节</h3><ol><li><p>方法完全可以没有结果，也就是没有返回值，但是方法必须要有返回值类型，用关键字void标记</p></li><li><p>实参的自动类型转换: 方法在调用时，如果填入的实参的数据类型，可以自动类型转换成形参的数据类型，那么即便数据类型不一致，语法上仍然允许该数据类型的变量作为实参。反之强制类型转换不行。方法的返回值和它的返回值类型也存在这种特点！(如果一个方法需要传入一个long类型数据，那我传入一个int值可以吗？如果传入double值可以吗?)</p></li><li><p>形参列表中起关键作用的是数据类型，它决定了调用该方法时需要传入什么数据。而</p><p>形参地名字实际上就是一个代号，仅会影响方法内部如何使用外部传入地数据，形参名叫什么其实无所谓。</p></li></ol><h2 id="main-方法详解" tabindex="-1"><a class="header-anchor" href="#main-方法详解" aria-hidden="true">#</a> main()方法详解</h2><p>main方法代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">//方法体	</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释如下：</p><ol><li><p>public static表示&quot;公开的，静态的&quot;，这两个修饰符很重要，我们等到面向对象阶段会重点学习它们。</p></li><li><p>void表示方法没有返回值。</p></li><li><p>main是方法名，代表这个方法是主方法，是程序的入口方法。</p><blockquote><p><strong>main不是关键字，但在Java中它已经成为约定俗成的程序入口方法的方法名。</strong></p><p>不要自定义一个方法叫main！</p></blockquote></li><li><p>（String[] args）是形参列表，其中String[]是一种引用类型，数组（马上讲），args是一个形参名</p><blockquote><p><strong>理论上来说，args可以在符合标识符命名的前提下可以任意写</strong>。但是不建议这么做</p></blockquote></li><li><p>main方法是启动程序时给<strong>JVM</strong>调用的，是程序的入口方法</p></li></ol><h2 id="练习" tabindex="-1"><a class="header-anchor" href="#练习" aria-hidden="true">#</a> 练习</h2><p>小试牛刀，完成以下练习题：</p><ol><li>求两个数的最大值。</li><li>键盘录入两个值，求最大值。</li><li>定义一个方法用于判断一个正整数的奇偶性，要求： <ol><li>奇数方法返回false</li><li>偶数方法返回true</li></ol></li><li>定义一个计算器（Calculator）它的功能有： <ol><li>加，减，乘，除</li><li>求平方</li><li>求a的n次方</li><li>...</li></ol></li><li>定义一个方法，求圆的面积： <ol><li>方法参数:半径 (radius)</li><li>圆周率:3.14（获取用Math.PI获取）</li></ol></li></ol><h1 id="方法重载" tabindex="-1"><a class="header-anchor" href="#方法重载" aria-hidden="true">#</a> 方法重载</h1><h2 id="引入-1" tabindex="-1"><a class="header-anchor" href="#引入-1" aria-hidden="true">#</a> 引入</h2><p>引例，现在有三个需求，需要写三个方法完成：</p><ol><li>编写程序，计算两个int类型数据之和，并输出结果</li><li>编写程序，计算两个double类型数据之和，并输出结果</li><li>编写程序，计算两个long类型数据之和，并输出结果</li></ol><p>写完方法后，请问这个程序有哪些缺点呢？</p><hr><p>很明显：</p><p>这三个方法实现的都是相似的功能，都是求和，只不过是针对的数据类型不同罢了。在正常情况下，我们认为方法的名字可以用来区分方法，但像引例中功能几乎一样的多个方法，能不能让它们拥有相同的方法名呢？这样既方便记忆，也方便调用。</p><p>Java是存在这种机制的，那就是Java的方法重载（overload）机制。方法重载允许一个类中，多个方法拥有相同的名字。但名字一旦相同后，多个方法之间又如何区分呢？</p><p><strong>所以方法的重载是有条件的。</strong></p><h2 id="语法要求" tabindex="-1"><a class="header-anchor" href="#语法要求" aria-hidden="true">#</a> 语法要求</h2><blockquote><p><span style="color:red;background:yellow;"><strong>一个类中的多个方法，可以具有相同的方法名，但是它们的形参列表必须不同。</strong></span></p></blockquote><p>形参列表不同意味着：</p><ol><li>形参数量不同</li><li>形参数量相同时，形参的数据类型不同</li><li>形参数量和数据类型都相同时，形参的数据类型的顺序不同</li></ol>`,26),f=n("strong",null,"经典的错误",-1),y=l(`<hr><p><strong>请明确记住，方法的重载只与方法的签名有关。即在方法名相同的情况下，方法签名不同，参数列表不同</strong></p><p>请思考：</p><p>如果我想在很多方法中，唯一地找到一个方法，需要明确什么？</p><h2 id="实参的自动类型转换在重载中的应用" tabindex="-1"><a class="header-anchor" href="#实参的自动类型转换在重载中的应用" aria-hidden="true">#</a> 实参的自动类型转换在重载中的应用</h2><p>先回答上面思考的问题：</p><blockquote><p>方法的调用必须能够让编译器明确找个某个方法，当多个方法的方法名相同，形参列表还相同的话，就无从唯一确定一个方法了。所以<strong>要想唯一确定一个方法，必须明确方法的名字和形参列表，而它两合起来就称之为&quot;方法的签名&quot;，这就是签名的由来。</strong></p></blockquote><p>一个类中发生方法重载时，方法名既然相同了，为了确保签名不同，那形参列表就必须不同了。</p><p>Demo1:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 方法1</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 方法2</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 方法3</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">float</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果调用的是:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请问调用的是方法几呢？</p><blockquote><p>在方法的概述这一节中，我们讲过：实参能够自动类型转换去匹配形参的数据类型，看起来方法1、2、3都能够匹配，那么究竟该选谁呢？这就不得不提，Java设计原则中一个非常重要的原则： <span style="color:red;background:yellow;"><strong>就近原则</strong></span></p></blockquote><p><strong>就近原则</strong> 指的是：当有多个选项都能正确匹配时，那么优先选择&quot;最近&quot;的。</p><p>回到上面那个案例，显然方法1最近，因为它不需要类型转换。而如果去掉方法1，那么方法3将胜出，因为它类型转换的&quot;距离&quot;会&quot;近&quot;一点。</p><p>理解就近原则，需要活学活用，以后我们还会碰到，到时候再解释。</p><p>Demo2:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 方法1</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 方法2</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如调用的代码是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请问调用的是方法1还是方法2呢？</p><p>显然不好确定，无论是1还是2都需要类型转换才能匹配，既然都转换，并且都是int------&gt;double，那么到底谁&quot;近&quot;呢？</p><p>实际上这个方法的调用，是一个模糊的调用，会编译报错。这一点在开发中，多个方法组成方法重载时，要格外注意。</p><h2 id="练习-1" tabindex="-1"><a class="header-anchor" href="#练习-1" aria-hidden="true">#</a> 练习</h2><p>小试牛刀：</p><ol><li>使用方法重载，控制台输出各种数据类型。</li><li>实现一个功能更强大的计算器。</li></ol>`,27);function _(w,x){const s=o("font");return i(),c("div",null,[d,n("p",null,[a("为了解决这个需求，我们就需要"),t(s,{color:"red"},{default:e(()=>[r]),_:1}),a("这种语法机制，这意味着方法（method）至少应该解决我们以下三个痛点：")]),k,v,n("p",null,[a("这实际上就是方法的作用。与此同时，我们还把使用"),t(s,{color:"red"},{default:e(()=>[m]),_:1}),a("去实现某种特定功能的过程叫做"),b]),h,t(s,{color:"red"},{default:e(()=>[a("**void方法没有返回值，但它有返回值类型，void本身就是一种返回值类型。**")]),_:1}),g,n("p",null,[a("除开上述条件外，其余的任何不同都无法构成方法重载， "),t(s,{color:"red"},{default:e(()=>[f]),_:1}),a("有：")]),n("ol",null,[n("li",null,[a("形参的名字不同，可以构成方法重载"),t(s,{color:"red"},{default:e(()=>[a("✖")]),_:1})]),n("li",null,[a("返回值类型不同，可以构成方法重载"),t(s,{color:"red"},{default:e(()=>[a("✖")]),_:1})]),n("li",null,[a("修饰符列表不同，可以构成方法重载"),t(s,{color:"red"},{default:e(()=>[a("✖")]),_:1})])]),y])}const S=p(u,[["render",_],["__file","2_方法.html.vue"]]);export{S as default};
