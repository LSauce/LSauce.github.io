import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o,c,b as n,d as s,e,w as p,f as a}from"./app-58d2c58f.js";const u="/assets/image-20221205144500325-6952a6dd.png",d={},r=a(`<h1 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h1><p>学习目标:</p><ul><li>掌握抽象类的定义</li><li>掌握抽象类的特点与使用</li></ul><h2 id="引例" tabindex="-1"><a class="header-anchor" href="#引例" aria-hidden="true">#</a> 引例</h2><p>以下猫狗继承案例，是一个非常基础的继承语法的代码。思考一下Animal类的继承体系，有什么问题吗？</p><p>从以下两个角度分析：</p><ol><li>从代码角度上，有没有冗余代码？</li><li>从设计角度上，在这个案例中，会存在一个动物对象吗？</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;动物叫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;猫叫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;狗叫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析一下</p><ol><li><p>单纯从代码角度上，有没有冗余代码？</p><p>实际上是有的。从方法调用的角度考虑，Animal类当中的shout方法从来没有被调用过。该方法单纯就是让子类继承并重写的，它实际上没有被调用的需求。从最理想的角度上来说，它的方法体是可以去掉的，仅保留一个声明让子类去重写就可以了。</p></li><li><p>当然代码多几行少几行并不重要，重要是：从设计角度出发，Animal类是一个抽象的概念，用于指代所有动物。程序中根本不需要创建它的对象。而且对于一个抽象的概念，也不应该、也不可能去描述它的行为。</p></li></ol><p>综上，我们提出两个改进的方向：</p><ol><li>Animal类就是作为顶层抽象祖先类而存在的，不需要创建对象，于是干脆不要创建对象了。</li><li>Animal类当中的shout方法不需要方法体，仅用于作为被继承和重写一个方法声明。</li></ol><p><strong>当父类的某些方法, 需要声明, 但是又不确定如何实现时, 可以将其声明为抽象方法, 那么这个类就是抽象类</strong></p><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><p>按照上述构想我们首先把方法的方法体去掉，这样就得到一个抽象方法。它的语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>修饰符列表<span class="token punctuation">]</span> <span class="token keyword">abstract</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注：</p><ol><li>抽象方法没有方法体，只有方法的声明（方法头）。但是不要忘记写分号&quot;;&quot;。</li><li><span style="color:red;background:yellow;"><strong>抽象方法必须写在一个抽象类中。</strong></span></li></ol><p>接下来，我们定义抽象类。它的语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>修饰符列表<span class="token punctuation">]</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> 类名<span class="token punctuation">{</span>
    <span class="token comment">//类体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过测试，我们发现抽象类不能创建对象，但抽象类可以继承，存在子类。并且抽象类作为父类，多态现象仍然存在。</p><p><span style="color:red;background:yellow;"><strong>在继承体系中，从祖先类开始，随着一个个子类的定义，子类变得越来越具体，而祖先类则更具有一般性和抽象性。在这种情况下，为了体现祖先类在设计上的抽象性，我们只将该类作为派生其他类的父类，而不能创建对象实例。这个时候，这样的类，我们称之为抽象类。</strong></span></p><img src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201071337543.png?align=center" alt="抽象类继承图" style="zoom:20%;"><p><strong>上层的类越来越抽象，下层的类越来越具体。</strong></p><h2 id="特点与使用" tabindex="-1"><a class="header-anchor" href="#特点与使用" aria-hidden="true">#</a> 特点与使用</h2><p><strong>特点</strong></p><p>抽象类的特点我们主要从以下角度：</p><ol><li>类名命名特点是什么?</li><li>能用哪些修饰符？</li><li>成员特点 <ol><li>普通成员</li><li>静态成员</li><li>抽象方法</li></ol></li><li>构造器</li><li>代码块</li></ol><p><strong>测试以后，结论如下：</strong></p>`,29),k=n("li",null,[n("p",null,[s("抽象类仍然是一个类，它的命名仍然需要遵循大驼峰的命名规范。当然，它比较特殊，许多公司的开发规范中，会要求将抽象类命名为"),n("code",null,"AbstracXxx"),s("或"),n("code",null,"BaseXxx"),s("，用于表示该类是一个抽象类。这是一个不错的命名习惯，推荐使用，但不强制。")])],-1),v=n("li",null,[n("p",null,"类class在定义时，本身可以使用的修饰符就比较少，除了访问权限修饰符之外，几乎就只有final、abstract等少数修饰符。但是但是final和abstract在修饰类时是冲突的，不能放在一起使用。final是阻止继承而abstract是抽象类，如果不继承抽象类没有任何意义。")],-1),m=n("p",null,"抽象类的成员特点：",-1),b=n("li",null,[n("p",null,"成员变量。抽象类可以定义普通类中能够定义的所有成员变量，在这一点上，和普通类是一样的。")],-1),h=n("li",null,[n("p",null,"成员方法。抽象类可以定义普通类中能够定义的所有成员方法，包括普通成员方法和静态成员方法，在这一点上，和普通类仍然是一样的"),n("p",null,"注：抽象类虽然不能创建对象，但是它有子类，这些具体实现方法可以让子类继承，子类可以选择直接使用，也可以选择重写，选择的权力在子类手上（假如一个方法在抽象类的多个子类中都需要被使用，那么就可以提取到抽象类中作为一个默认实现）"),n("p",null,[s("综上，不能发现： "),n("span",{style:{color:"red",background:"yellow"}},[n("strong",null,"普通类中能够定义的成员，在抽象类中都是可以定义的。")])])],-1),g=n("strong",null,"定义出一个抽象类，就是为了定义抽象方法的。",-1),y=n("span",{style:{color:"red",background:"yellow"}},[n("strong",null,'"占位"')],-1),f=n("p",null,"如果子类不想实现抽象父类中的抽象方法，可以把子类也设置为抽象类，抽象类就不需要实现父类中的抽象方法了。",-1),w=n("li",null,[n("p",null,[s("构造器。构造器除了可以自己用，创建对象时给成员变量赋值，还可以给子类用，在子类对象初始化过程中，可以调用父类的构造方法给父类的成员变量赋值。所以抽象类虽然不能创建对象，但它也是有构造器的。实际上，"),n("span",{style:{color:"red",background:"yellow"}},[n("strong",null,"在Java中，任何一个类都有构造器。")])])],-1),x=n("li",null,[n("p",null,"代码块，无论是构造代码块，还是静态代码块，都有。")],-1),q=a('<p>综上：抽象类实际上和普通类能够定义的成员是一样的，普通类中有的东西它都有，只不过多了一个抽象方法。<span style="color:red;background:yellow;"><strong>在不考虑创建对象的情况下，直接把一个类声明为abstract，是不会编译报错的。</strong></span></p><hr><p><strong>使用</strong></p><p><strong>抽象类的使用，我们主要探讨，它的子类特点。</strong></p><p>抽象类的子类可以有两种情况：</p><ol><li>子类是普通类，普通类继承抽象类，必须实现所有的抽象方法。</li><li>子类是抽象类，抽象子类不需要实现抽象方法，抽象子类可以自由选择实现（或实现或不实现）。</li></ol><p>注：抽象类还可以继承一个普通类, 实际上如果一个抽象类, 它没有直接父类, 那它就直接继承Object</p><h2 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h2><ol><li><p>abstract关键字，不能用来修饰构造器、属性、代码块等结构。只能修饰类或者方法。</p></li><li><p>abstract修饰类时，类的修饰符不能有final。</p></li><li><p>abstract修饰方法时，该方法不能有修饰符：</p><ol><li>private</li><li>static</li><li>final</li></ol></li><li><p>一个抽象类中可以没有抽象方法，但是没有意义</p></li></ol><h2 id="练习" tabindex="-1"><a class="header-anchor" href="#练习" aria-hidden="true">#</a> 练习</h2><blockquote><p>普通员工包含3个属性：姓名、工号以及工资，行为是工作</p><p>程序员包含3个属性：姓名、工号以及工资，行为是工作和加班（overtime work）</p><p>经理包含4个属性：姓名、工号、工资以及奖金（bonus），行为是工作</p></blockquote><ul><li>请使用所学的知识设计该员工系统</li><li>要求类中提供必要的方法进行属性访问（description）</li></ul><p>类图结构</p><figure><img src="'+u+'" alt="image-20221205144500325" tabindex="0" loading="lazy"><figcaption>image-20221205144500325</figcaption></figure>',14),j={start:"2"},S=n("strong",null,'只要是继承，就必须考虑"is-a"关系。',-1),_=a(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 抽象的员工类</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BaseStaff</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">BaseStaff</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 定义打印属性的方法,子类可以选择直接使用,也可以选择重写</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printStaff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;id是&quot;</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">&quot;的员工,姓名是&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;,Ta的工资是&quot;</span> <span class="token operator">+</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> salary<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">NormalStaff</span> <span class="token keyword">extends</span> <span class="token class-name">BaseStaff</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">NormalStaff</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> id<span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;负责杂项工作&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Coder</span> <span class="token keyword">extends</span> <span class="token class-name">BaseStaff</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Coder</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> id<span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;负责技术开发&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">overTimeWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;996福报,蹭公司电,蹭公司网!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">BaseStaff</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> bonus<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">,</span> <span class="token keyword">double</span> bonus<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> id<span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>bonus <span class="token operator">=</span> bonus<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;负责统筹规划&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printStaff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;id是&quot;</span> <span class="token operator">+</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;的员工,姓名是&quot;</span> <span class="token operator">+</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;,Ta的工资是&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> bonus<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h1><p>学习目标:</p><ul><li>掌握接口的定义</li><li>掌握接口的特点与使用</li></ul><h2 id="引例-1" tabindex="-1"><a class="header-anchor" href="#引例-1" aria-hidden="true">#</a> 引例</h2><p>在之前的猫狗案例中，我们将Animal类设置为抽象类，继承体系代码如下：</p><p>猫狗案例代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;猫叫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;狗叫&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们有了新需求：一部分猫和狗，经过了特殊训练，能够<mark>直立行走</mark>了。那么这群特殊的猫和狗，怎么描述它们呢？</p><p>分析：</p><p>部分猫和狗经过特殊训练，才能够直立行走。所以不可能直接加个方法到Cat类和Dog类中，不是所有猫狗都有这个行为。而特殊的猫狗仍然是猫和狗，所以它们肯定还要继承猫和狗这两个类。可能很多同学，这时候想到的就是：重新定义两个新的猫狗类（比如超级狗和猫）继承猫狗，然后给出直立行走的方法就算完事了。这样做不是不行，需求是实现了，但还有一些小问题：</p><ol><li>一方面没有体现代码复用。</li><li>更重要的是，没有体现出特殊训练的过程。假如还有一些动物也要直立行走，增加这个行为，如何体现出规范性、标准性呢？体现出它们是特殊的经过训练的动物呢？</li></ol><p>这里我们想到了抽象类，因为抽象类中抽象方法，可以强制约束子类实现它，这样就是一种标准和规范，体现了它经过了特殊训练，和之前不同了。</p><p>于是我们定义抽象类，给出抽象方法，让超级猫狗类去继承这个抽象类，可行吗？</p><p>理想很美好，现实很骨感。显然做不到，因为Java不支持多继承。除开这点这么做也不是完美的，问题是：</p><ol><li>这个抽象类里面是对功能和行为的抽象，缺少属性（单独一个直立行走的行为是一个什么对象？）所以单独的行为不应该被抽象为类，不符合类的定义。</li><li>继承这个抽象类也不符合继承的&quot;is-a&quot;关系，这里不适用继承（还是上面那句话，行为根本不是个体）</li></ol><p>于是，我们就迫切需要一种全新的数据类型，这种全新的数据类型：</p><ol><li>不强调属性，只强调行为的抽象，&quot;继承&quot;它表示功能的扩展。</li><li>在一个类继承某个类后，还能继续&quot;继承&quot;，不受Java单继承限制。</li><li>没有&quot;is-a&quot;这种继承关系的限制。</li><li>最好还有抽象方法。（因为它能表示规范和标准）</li></ol><p>这种全新的数据类型，就是<strong>接口（interface）</strong>。</p><p>如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们实现这个接口，各自实现自己具体的处理方法来处理那个目标</p><h2 id="定义-1" tabindex="-1"><a class="header-anchor" href="#定义-1" aria-hidden="true">#</a> 定义</h2><p>上面四条，其实已经描述了接口的特点，接口是一种表示对行为抽象的，不受Java多继承限制的，用来作为功能扩展标准的一种引用数据类型。它的定义语法如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">interface</span> 接口名<span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：</p><ul><li><p>接口的访问权限修饰符也只有两种：</p><ol><li>public</li><li>默认缺省的</li></ol></li><li><p>接口名和类名一样，遵循大驼峰式的书写规范，接口名最好起的见名知意。有些程序员喜欢在接口前加一个大写字母I来直接，表示该类型是一个接口，可以借鉴，但不强制。</p></li><li><p>接口中可以定义抽象方法，和抽象类中定义抽象方法没有区别。</p></li><li><p>接口是可以被一个类&quot;继承&quot;的，接口的&quot;继承&quot;，更准确、常见的叫法称之为接口的实现。当然它也不再使用extends关键字，而是使用 implements 关键字。一个普通类实现接口必须实现所有抽象方法。它的语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> 类名 <span class="token keyword">extends</span> 类名 <span class="token keyword">implements</span> 接口名 <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>细节问题：如果一个类实现接口并继承别的类，要&quot;<mark>先继承再实现</mark>&quot;。关键字位置不要写反了。</p></li><li><p>在接口的实现中，可以称呼接口为&quot;父接口&quot;，接口的实现类为&quot;子类&quot;，它们仍然是父子关系。当然多态现象仍然能够发生。</p></li><li><p>接口不受多继承限制，一个类可以在继承别的类的同时实现接口，而且可以实现多个接口。</p></li></ul><h2 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h2><p>使用接口有如下优点：</p><ul><li>接口<mark>不受单继承限制</mark>，这是接口非常重要的优点。</li><li>接口不是类，它和它的实现类，也不需要存在&quot;is-a&quot;关系，接口比抽象类的使用更加灵活。 <ul><li>程序开发中将接口和它的实现类之间的关系，称之为&quot;like-a&quot;关系。只要是<mark>实现了Xxx的功能，就像Xxx</mark>。</li></ul></li><li>接口表示一种开发标准，一种规范。表示对功能的扩展，它只关注行为，不关注属性。</li></ul><h2 id="特点和使用" tabindex="-1"><a class="header-anchor" href="#特点和使用" aria-hidden="true">#</a> 特点和使用</h2><p><strong>接口的特点我们主要研究以下方面</strong></p><ol><li>接口的声明特点 <ol><li>接口能不能创建对象?</li><li>接口能不能用final修饰?</li></ol></li><li>接口的实现类的书写格式</li><li>成员特点 <ol><li>能否定义属性(成员变量, 静态成员变量, 全局常量)?</li><li>能否定义方法/行为?</li></ol></li><li>构造器</li><li>代码块</li></ol><p><strong>测试后，我们的结论是：</strong></p><ul><li><p><strong>接口的声明特点</strong></p><ul><li>接口能不能创建对象? <ul><li>不能创建对象,实际上接口是抽象的. 因为接口的声明修饰符中隐含了关键字abstract</li></ul></li><li>接口能不能用final修饰? <ul><li>不能,接口定义出来目的就是为了被实现. final天生和接口矛盾</li></ul></li></ul></li><li><p><strong>接口的命名特点(非强制)</strong></p><ul><li>接口在命名时,为了体现接口的特殊性,表示它是一个接口. 某些程序员会在接口的命名前加大写字母&quot;I&quot;</li></ul></li><li><p><strong>接口的实现类的书写格式(非强制)</strong></p><ul><li>某些程序员会在接口的所在位置,定义一个全新的包,叫&quot;impl&quot;</li><li>然后在该包下写接口的实现类,命名为&quot;接口名 + Impl&quot;</li></ul></li><li><p><strong>成员特点</strong></p><ul><li>能不能定义属性?(成员变量,静态成员变量,全局常量) <ul><li>可以定义,但是接口中的属性默认都是&quot;public static final&quot;修饰的公共的全局常量</li><li>这些隐含的修饰符不要写出来, 接口能够定义的所有结构的访问权限都是public, 而且public是隐含的修改不了</li><li>接口中没有静态代码块,接口中的全局常量,必须显式赋值</li><li>接口表示对功能的扩展,所以接口往往只有对行为的抽象(接口往往只有方法),接口是非常少见定义属性的, 只有当接口的所有实现类,都需要一个共同的全局常量时才考虑在接口中定义属性.</li></ul></li><li>能不能定义方法/行为? <ul><li>可以定义方法,但是接口中的方法默认都是&quot;public abstract&quot;修饰的公共的抽象方法</li><li>实际上,在Java8之前,接口中没有任何实现方法,接口中只能定义抽象方法</li><li>特别强调: 实际开发中,99%的情况下,接口就只有光秃秃的抽象方法定义,没有其他任何内容</li></ul></li></ul></li><li><p><strong>构造器</strong></p><ul><li>接口是没有构造器的,接口自己用不到构造器</li></ul><ul><li><pre><code>     接口的子类也用不到
</code></pre></li></ul></li><li><p><strong>代码块</strong></p><ul><li>没有静态代码块</li></ul><ul><li><pre><code>     没有构造器就没有构造代码块
</code></pre></li></ul></li><li><p><strong>以上总结,接口能定义的结构特点:</strong></p><ul><li>可以定义<mark>全局常量</mark></li></ul><ul><li><pre><code>     可以定义==抽象方法==(Java8以后允许实现方法)
</code></pre></li></ul><ul><li>实际上,接口往往只有抽象方法定义,它表示对行为的抽象, 表示制定标准和规范</li></ul></li></ul><p><strong>注意两个问题:</strong></p><ol><li>实现接口的类，如果没有明确继承一个其他类，那么子类对象的隐式初始化super()指向Object类。</li><li>接口虽然不是类，但是它也<mark>继承了Object类</mark>。</li></ol><p><strong>接口的使用，我们主要探讨它的子类特点。</strong></p><p>接口的子类可以是什么？</p><ol><li><p>普通类实现接口，必须实现所有的抽象方法。</p></li><li><p>抽象类实现接口，<mark>按需实现抽象方法</mark>。</p></li><li><p>接口可以继承一个接口，并且接口在继承接口后，可以重写父接口中的抽象方法和默认方法。 <mark>接口之间可多继承extends</mark></p><p>参考如下代码（了解即可）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
   
<span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
        重写父接口抽象方法
            只有在父接口的方法返回值类型是父类类型时
            子接口中可以将抽象方法返回值类型重写为子类类型
            其余地方都不可变。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">Demo</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="extends-vs-implements" tabindex="-1"><a class="header-anchor" href="#extends-vs-implements" aria-hidden="true">#</a> extends VS implements</h2><p>实现（Implement）：如果多个类处理的目标是一样的，但是<mark>处理的方法方式</mark>不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标</p><p>继承: 指的是一个类（称为子类）继承另外的一个类（称为父类）的功能，并可以增加它自己的新功能的能力。所以，继承的根本原因是因为要复用，而实现的根本原因是<mark>需要定义一个标准</mark></p><blockquote><p>简单点说，就是同样是一台汽车，既可以是电动车，也可以是汽油车，也可以是油电混合的，只要实现不同的标准就行了，但是一台车只能属于一个品牌，一个厂商。</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token keyword">extends</span> <span class="token class-name">Benz</span> <span class="token keyword">implements</span> <span class="token class-name">GasolineCar</span><span class="token punctuation">,</span> <span class="token class-name">ElectroCar</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
我们定义了一辆汽车，他实现了电动车和汽油车两个标准，但是他属于奔驰这个品牌。像上面这样定义，我们可以最大程度的遵守标准，并且复用奔驰车所有已有的一些功能组件。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>继承（extends）是不能跨越种族的，类和类继承，<mark>接口和接口继承</mark>，<mark>接口和类之间没有继承关系</mark>。</p><ol><li>普通类继承一个抽象类，需要实现里面的所有抽象方法。</li><li>抽象类继承一个抽象类，按需实现里面的抽象方法。</li><li>抽象类继承一个普通类，是可以的。</li><li>接口在继承一个接口后，会得到接口的所有抽象方法。</li><li>类的继承是单继承的，<mark>接口的继承是多继承</mark>的。</li></ol><p>实现（implements），必须发生在<mark>类与接口</mark>之间，接口和类是没有任何关系的。</p><ol><li>普通类实现接口，必须实现所有抽象方法</li><li><mark>抽象类实现接口，按需实现抽象方法</mark></li></ol><h2 id="默认方法和静态方法" tabindex="-1"><a class="header-anchor" href="#默认方法和静态方法" aria-hidden="true">#</a> 默认方法和静态方法</h2><p><strong>Java8中接口的语法迎来了大的变动，新增了两种具有方法体的实现方法：</strong></p><ul><li>默认方法</li><li>静态方法</li></ul><ol><li><p>默认方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 默认方法的语法:</span>
<span class="token keyword">default</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//方法体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>接口中的<mark>默认方法的访问权限修饰符是public</mark>，不可更改。全局变量和抽象方法，默认方法，静态方法都为 public</li><li>默认方法的作用： <ul><li>抽象类中的实现方法是用来作为子类的默认实现的，但是接口不具备这个功能。接口表示对功能的扩展，它更多的是一种标准和规范，多数情况下它不需要实现方法。</li><li>Java8仍然新增了默认方法，主要是两个角度考虑: <ul><li>接口中一旦有了默认实现方法，<mark>程序设计接口的灵活性</mark>就增加了。在没有默认方法时，接口中一旦新增任何方法，子类都必须实现它。而现在有了默认方法，就不需要这么做：需要实现的就自己重写，不需要的就直接继承。代码的兼容性和灵活性就增加了。</li><li>Java8中引入了Lambda表达式和StreamAPI，接口中的默认方法可以作为它们的实现，完成<mark>函数式编程</mark>。（这个仅了解，后面会讲Lambda表达式）</li></ul></li><li>接口中的默认方法，还可以配合接口的&quot;多实现&quot;，实现真正意义上的多继承。</li></ul></li></ul></li><li><p>静态方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//方法体</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>接口中的静态方法也是<mark>默认public修饰</mark>的，不可更改。</li></ul></li></ol><ul><li>它的调用方式是用接口名.静态方法名。 <ul><li>接口中的静态方法也是为了<mark>配合Lambda表达式和StreamAPI</mark>使用的，其余场景不多见。</li><li>接口自从Java8以后有了静态方法，甚至可以写一个main方法。</li><li><strong>接口中的静态实现方法，只能自己用，不能用实现类类名调用。</strong></li></ul></li></ul><hr><p><strong>上面两种方法仅供了解，实际开发中，可能会偶尔见到它，但自己写的概率非常小。</strong></p><h2 id="练习-1" tabindex="-1"><a class="header-anchor" href="#练习-1" aria-hidden="true">#</a> 练习</h2><ol><li>教练（Coach）和运动员（Sportsman）案例</li></ol><blockquote><p>小试牛刀请用所学知识分析：这个案例中有哪些抽象类，哪些接口，哪些具体类。</p></blockquote><p>现在有乒乓球运动员和篮球运动员，乒乓球教练和篮球教练。为了能够出国交流，跟乒乓球相关的人员都需要学习英语。</p><ol start="2"><li><span style="color:red;background:yellow;font-size:文字大小;font-family:字体;"><strong>(重要)</strong></span>某电商系统后台，前端程序员需要后端程序员，提供接口来完成商品的管理，展示页面。假如前后端商量好，要求能实现CRUD操作, 采用MVC分层思想, 业务逻辑如下: <ul><li>展示全部商品（Products）页面时，将仅装有商品对象的数组返回，前端不提供任何数据。</li><li>新增商品时，前端提供商品各种参数，后端需要校验ID唯一性，然后将对象插入数组，返回插入结果(true/false)。</li><li>查询商品, 前端提供商品ID或者商品名称(可根据ID查询或者根据商品名称查询), 后端根据信息查询商品详情, 并返回结果(商品对象)</li><li>更新商品(每次更新商品中的一个信息即可), 前端提供要被更新的商品ID, 以及新的产品信息(可以用数组的形式存储新的产品信息), 后端根据商品ID找到该商品, 并将新的信息替换, 返回该商品对象.</li><li>删除商品时，前端提供商品ID，后端将该商品删除后，返回删除结果。（成功返回true，根据ID找不到该商品即删除失败返回false）</li></ul></li></ol><h2 id="方法的形参和返回值类型" tabindex="-1"><a class="header-anchor" href="#方法的形参和返回值类型" aria-hidden="true">#</a> 方法的形参和返回值类型</h2><h3 id="方法传值" tabindex="-1"><a class="header-anchor" href="#方法传值" aria-hidden="true">#</a> 方法传值</h3><p>方法的形参在方法调用传入实参时，不一定要求数据类型完全一致。</p><ul><li>**基本类型：**对于基本数据类型的方法形参，存在自动类型提升。</li><li><strong>引用类型：</strong> 对于引用数据类型的方法传参，存在自动向上转型。 <ol><li>形参如果写一个普通类：调用方法时需要传入的是该类的对象或者该类的子类对象</li><li>形参如果写一个抽象类：调用方法时需要传入的是该抽象类的子类对象</li><li>形参如果写一个接口：调用方法时需要传入的是该接口的子类对象</li></ol></li></ul><h3 id="方法的返回值" tabindex="-1"><a class="header-anchor" href="#方法的返回值" aria-hidden="true">#</a> 方法的返回值</h3><p>方法的返回值类型，和在方法体中返回具体值（对象）时，不一定要求数据类型完全一致。</p><ul><li>**基本类型：**方法体中，返回一个具体的值不要求和返回值类型完全一致，存在自动类型提升。</li><li><strong>引用类型：</strong> 在方法体中，返回一个对象时不要求就是返回值类型的对象，存在自动向上转型。 <ol><li>返回值类型如果写一个普通类：可以返回该类的对象或者该类的子类对象</li><li>返回值类型如果写一个抽象类：返回该抽象类的子类对象。</li><li>返回值类型如果写一个接口：返回该接口的子类对象。</li></ol></li></ul><h3 id="方法重写中的返回值类型问题" tabindex="-1"><a class="header-anchor" href="#方法重写中的返回值类型问题" aria-hidden="true">#</a> 方法重写中的返回值类型问题</h3><p>父子类方法重写中，方法声明中返回值类型的书写。</p><ol><li>**基本类型和void：**必须保持一模一样，不存在类型提升。</li><li>**引用类型：**不必保持一模一样，存在自动向上转型。 <ol><li>类：父类中的方法返回一个普通类类型 <ul><li>子类方法中可以返回该类型</li><li>也可以返回该类的子类类型</li></ul></li><li>抽象类：父类中的方法返回一个抽象类类型 <ul><li>子类方法可以返回该类型</li><li>也可以返回抽象类的实现类类型</li></ul></li><li>接口：父类中的方法返回一个接口类型 <ul><li>子类方法可以返回该类型</li><li>也可以返回接口的实现类类型</li></ul></li></ol></li></ol><h2 id="链式调用" tabindex="-1"><a class="header-anchor" href="#链式调用" aria-hidden="true">#</a> 链式调用</h2><p>链式调用，在Java代码中是很常见的。当然它不是一个语法，这里讲一下它的形式，大家知道即可。</p><p>对于类Studnet：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>

 <span class="token keyword">public</span> <span class="token class-name">Student</span> <span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">public</span> <span class="token class-name">Teacher</span> <span class="token function">getTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;秀一波~~~&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如在main方法中写以下代码（不使用链式调用）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">StudentDemo</span> sd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StudentDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span> s <span class="token operator">=</span> sd<span class="token punctuation">.</span><span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用链式调用的形式为：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">StudentDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><span style="color:red;background:yellow;"><strong>链式调用的本质在于：前面方法的返回值是一个对象。</strong></span></p><h1 id="接口-vs-抽象类" tabindex="-1"><a class="header-anchor" href="#接口-vs-抽象类" aria-hidden="true">#</a> 接口 VS 抽象类</h1><p>接口和抽象类的异同：</p><table><thead><tr><th style="text-align:center;">编号</th><th style="text-align:center;"><strong>区别点</strong></th><th style="text-align:center;"><strong>抽象类</strong></th><th style="text-align:center;"><strong>接口</strong></th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;">定义</td><td style="text-align:center;">包含抽象方法的类</td><td style="text-align:center;">抽象方法和全局常量的集合</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;">组成</td><td style="text-align:center;">构造方法、抽象方法、普通方法、常量、变量</td><td style="text-align:center;">常量、抽象方法、(jdk8:默认方法、静态方法)</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;">使用</td><td style="text-align:center;">子类继承抽象类(extends)</td><td style="text-align:center;">子类实现接口(implements)</td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;">关系</td><td style="text-align:center;">抽象类可以实现多个接口</td><td style="text-align:center;">接口不能继承抽象类，但允许继承多个接口</td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;">对象</td><td style="text-align:center;">不能创建对象，但是有构造方法</td><td style="text-align:center;">不能创建对象，也没有构造方法</td></tr><tr><td style="text-align:center;">6</td><td style="text-align:center;">局限</td><td style="text-align:center;">抽象类不能被多继承</td><td style="text-align:center;">接口之间能多继承，能被多实现</td></tr><tr><td style="text-align:center;">7</td><td style="text-align:center;">思想</td><td style="text-align:center;">作为模板或对共性属性和行为抽象，is-a</td><td style="text-align:center;">作为标准或对共性行为抽象，like-a</td></tr><tr><td style="text-align:center;">8</td><td style="text-align:center;">访问权限</td><td style="text-align:center;">抽象类的成员，写访问权限比较自由。</td><td style="text-align:center;">接口的成员，必须是public修饰的</td></tr><tr><td style="text-align:center;">9</td><td style="text-align:center;">选择</td><td style="text-align:center;"><strong>如果抽象类和接口都可以使用的话，优先使用接口，避免单继承的局限</strong></td><td style="text-align:center;"></td></tr></tbody></table><p>总之，抽象类和接口除了都是抽象外，区别相当明显。抽象类是作为继承层次中的顶层父类存在的，接口则比较自由。</p><h1 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类" aria-hidden="true">#</a> 内部类</h1><ul><li>熟悉不同内部类的语法</li><li>熟悉不同内部类的访问特点</li></ul><h2 id="引例-2" tabindex="-1"><a class="header-anchor" href="#引例-2" aria-hidden="true">#</a> 引例</h2><p>引例</p><blockquote><p>我们现在做一个应用程序，需要描述一台电脑中的CPU，对于电脑而言，该怎么去描述这个CPU呢？</p></blockquote><p>分析：</p><p>我们可以创建两个类，一个描述Computer，一个描述CPU。但这样明显是有问题的：</p><ol><li>CPU是电脑中最重要的组件，但它脱离电脑存在就是一粒沙子。这意味着CPU对象，应仅存在于Computer内部。</li><li>CPU可以控制计算机的一切硬件资源。这意味CPU对象能够操控，Computer类中的所有成员，无论私有。</li></ol><p>定义普通类CPU是不能完成需求的，因为：</p><ol><li>普通类没有私有概念，不可能控制仅能在Computer内部创建对象。</li><li>普通类不可能直接访问，其它类的私有成员。</li></ol><p><strong>显然CPU类不应该是一个普通类，不应该是一个独立的类 ---&gt; 不再将CPU类定义为一个独立的类，而是将它放入Computer类的类体中，可以近似的看成是一个Computer类的成员 ---&gt; CPU类近似看成Computer类的成员，于是：</strong></p><ol><li>在其它类内部的类，就有了私有概念，就有了四种访问权限。只需要在内部私有化一个类，那么在外界就无法创建它的对象了。</li><li>既然已经成为了成员，成为了&quot;自己人&quot;，那么就不再受限于权限控制了，内部类就可以访问包裹它的类的所有成员，包括私有。</li></ol><p>上述两条，其实就是（成员）内部类的主要特点。也说明了使用内部类的主要场景：</p><ol><li>内部类是一种比类更加极致的封装思想体现，内部类的成员不仅被类自身保护，还被包裹着它的类保护。</li><li>内部类和包裹它的类互相成为了&quot;好兄弟&quot;，互相访问成员都不受访问权限限制。</li></ol><p>当你有以上使用场景时，就可以考虑使用内部类。</p><h2 id="定义与分类" tabindex="-1"><a class="header-anchor" href="#定义与分类" aria-hidden="true">#</a> 定义与分类</h2><p><strong>基本概念:</strong></p><p>在Java语言中类可以嵌套定义，广义的内部类指的是定义在另一类当中的一个类。</p><p><strong>分类:</strong></p><p>根据内部类在类中定义的位置不同:</p><ul><li><strong>成员位置</strong><ul><li>成员内部类</li><li>静态内部类</li></ul></li><li><strong>局部位置</strong><ul><li>局部内部类</li><li>匿名内部类</li><li>Lambda表达式</li></ul></li></ul><p>但是我们在学习的时候，不按定义位置来学习。我们按照它是一个类，还是一个对象来分类：</p><ol><li>语法定义了一个类，包括成员内部类、静态内部类和局部内部类。既然是定义了一个类，使用时还需要创建对象才能用。</li><li>语法直接创建了一个对象，包括匿名内部类和Lambda表达式。由于已经通过语法创建了对象，可以直接使用。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 外部类</span>
<span class="token keyword">class</span> <span class="token class-name">Computer</span><span class="token punctuation">{</span>
	<span class="token comment">// 内部类</span>
    <span class="token keyword">class</span> <span class="token class-name">CPU</span><span class="token punctuation">{</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 外部其他类</span>
<span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了上课方便，我们需要统一口径，在内部类课程当中，我们统一规定：</p><ol><li>像CPU这种，定义在别的类的内部的类，我们称之为内部类.</li><li>像Computer这种，包裹内部类的，我们称之为外部类.</li><li>Demo这种类我们称之为外部其他类.</li></ol><p>学习方式:<br> 1.定义的位置<br> 2.权限修饰符<br> 3.成员特点<br> 4.继承和实现<br> 5.访问特点<br> 内部类-----&gt;外部类<br> 外部类-----&gt;内部类<br> 内部类-----&gt;外部其他类<br> 外部其他类---&gt;内部类</p><h2 id="成员内部类" tabindex="-1"><a class="header-anchor" href="#成员内部类" aria-hidden="true">#</a> 成员内部类</h2><p>成员内部类是最普通的内部类，它定义在另一个类的成员位置， 可以看成<strong>该类的一个成员。</strong></p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//外部类</span>
<span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token class-name">OuterClazz</span><span class="token punctuation">{</span> 
<span class="token comment">//成员内部类</span>
	<span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token class-name">InnerClazz</span><span class="token punctuation">{</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自身特点" tabindex="-1"><a class="header-anchor" href="#自身特点" aria-hidden="true">#</a> 自身特点</h3><h4 id="访问权限修饰符" tabindex="-1"><a class="header-anchor" href="#访问权限修饰符" aria-hidden="true">#</a> 访问权限修饰符</h4><p><strong>成员内部类可以看成另一个类的成员，它和类中成员一样，有四种访问权限级别：</strong></p><ul><li>public</li><li>protected</li><li>缺省的，默认访问权限</li><li>private</li></ul><p>注：</p><ol><li>外部类可以保护成员内部类，如果想要访问一个成员内部类。首先需要外部类权限，然后还需要成员内部类权限。</li><li>都定义成员内部类了，多数情况下，应该私有化它。</li></ol><h4 id="成员特点" tabindex="-1"><a class="header-anchor" href="#成员特点" aria-hidden="true">#</a> 成员特点</h4><ol><li>可以定义普通成员变量，成员方法。但没有静态声明（包括静态变量，静态方法，静态代码块）</li><li>有构造器，有构造代码块。</li><li>可以有静态全局常量。</li></ol><p>注意:</p><ul><li>允许定义字面值常量赋值的全局常量, 也就是<mark>不会触发类初始化的全局常量</mark></li></ul><h4 id="继承和实现" tabindex="-1"><a class="header-anchor" href="#继承和实现" aria-hidden="true">#</a> 继承和实现</h4><ul><li>内部类可以继承和实现外部的类和接口。</li><li>也可以在类中定义多个普通类、抽象内部类和接口用来自己继承和实现。</li></ul><h3 id="成员内部类的访问特点" tabindex="-1"><a class="header-anchor" href="#成员内部类的访问特点" aria-hidden="true">#</a> 成员内部类的访问特点</h3><p>在具体了解成员内部类的使用之前,我们要搞清楚成员内部类和外部类之间,到底什么关系?</p><ul><li><p>成员内部类可以看成外部类的一个成员</p></li><li><p>类中的成员变量,必须依赖于类的对象而存在, 那么成员内部类的对象,也必须依赖于外部类对象而存在</p></li><li><p>也就是说,要想得到成员内部类对象,必须在外部类对象的基础上创建,成员内部类对象不能单独创建, 成员内部类依赖于外部类,反过来,没有依赖关系</p></li></ul><p>之所以存在这样的依赖关系:</p><p>是因为成员内部类对象的成员变量列表中,都会持有外部类对象的引用(成员内部类对象中保存了一个它所寄生的外部类对象的引用)</p><h4 id="成员内部类内部访问外部类-重点" tabindex="-1"><a class="header-anchor" href="#成员内部类内部访问外部类-重点" aria-hidden="true">#</a> 成员内部类内部访问外部类(重点)</h4>`,131),I=a('<p>在成员内部类的成员方法中访问外部类成员，因为外部类对象已经存在，所以可以直接访问，直接写成员的名字就可以了。在特殊情况下，当成员内部类成员和外部类成员同名时，如果仍然用成员名直接访问，访问的结果是成员内部类自身成员（就近原则），这时：</p><ol><li>在成员内部类的成员方法中，自身对象用this指向，用this点访问到的一定是自身成员。</li><li>在成员内部类的成员方法中，外部类对象用外部类类名.this指向，用外部类类名.this点访问到的一定是外部类成员。</li></ol><p>极限情况下，出现局部变量，成员内部类成员变量，外部类成员变量三者都同名的情况：</p><ol><li>就近原则直接写成员名字，访问的是局部变量的。</li><li>用this.访问的成员内部类自己的成员变量。</li><li>用外部类类名.this.访问的是外部类的成员变量。</li></ol><p>最后，如果全局常量同名了，就用类名去区分好了。</p><h4 id="外部类访问成员内部类成员-重点" tabindex="-1"><a class="header-anchor" href="#外部类访问成员内部类成员-重点" aria-hidden="true">#</a> 外部类访问成员内部类成员(重点)</h4>',6),C=a(`<p>第二，外部类访问成员内部类成员，要分两种情况：</p><ul><li><p>外部类的成员方法中访问成员内部类成员：</p><ol><li>因为这时成员内部类对象不存在，就需要先创建它的对象。</li><li>成员内部类对象依赖外部类对象而存在， 所以得先存在外部类对象才行。而恰好成员方法中隐含自身对象，所以这里创建成员内部类对象的方式就是—— <span style="color:red;background:yellow;"><strong>直接new创建。</strong></span></li></ol><p>创建对象后，直接用对象名点访问即可。如果有同名的情况，用成员内部类对象名访问的就是内部类的成员，反之不写对象名或者写this访问的都是外部类的成员。</p></li><li><p>外部类的静态成员方法中访问成员内部类成员：</p><ol><li><p>成员内部类对象不存在，就需要先创建它的对象。</p></li><li><p>成员内部类对象依赖外部类对象而存在， 所以得先存在外部类对象才行。但静态方法中什么对象都没有，就需要先创建外部类对象，再创建成员内部类对象。</p><p>语法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">OuterClazz</span> outer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">InnerClazz</span> inner <span class="token operator">=</span> outer<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 上面等价于下面</span>
<span class="token class-name">InnerClazz</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到两个对象后，用谁的对象名访问的就是谁的成员。</p></li></ol></li></ul><h4 id="外部其他类访问成员内部类成员-了解" tabindex="-1"><a class="header-anchor" href="#外部其他类访问成员内部类成员-了解" aria-hidden="true">#</a> 外部其他类访问成员内部类成员(了解)</h4><p>外部其他类要访问成员内部类成员，条件要苛刻的多。由于成员内部类属于外部类的一个成员，所以首先外部其他类需要有外部类的访问权限，再次还需要成员内部类的访问权限。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">OuterClazz<span class="token punctuation">.</span>InnerClazz</span> oi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>创建对象后，用对象名访问成员即可。</strong></p><h4 id="成员内部类访问外部其他类成员-了解" tabindex="-1"><a class="header-anchor" href="#成员内部类访问外部其他类成员-了解" aria-hidden="true">#</a> 成员内部类访问外部其他类成员(了解)</h4><p>在成员内部类中访问外部类成员，和在普通类中访问其它类成员别无二致：</p>`,8),L=n("li",null,"静态成员直接类名点访问。",-1),D=n("li",null,"普通成员需创建外部类对象去访问。",-1),A=a(`<p>**总结 **</p><pre><code>-  
-  
</code></pre><h3 id="练习-2" tabindex="-1"><a class="header-anchor" href="#练习-2" aria-hidden="true">#</a> <mark>练习</mark></h3><ul><li>内部类和外部类 互相调用无 权限限制</li></ul><ol><li><p>试着说一说下述访问，能否进行，怎么进行，是否受访问权限限制。</p><ol><li>成员内部类的成员方法中，去访问外部类的成员。 <ul><li>无权限限制，使用 成员名访问即可</li></ul></li><li>外部类的成员方法中，去访问成员内部类的成员。 <ul><li>无权限现在,new对象后 去访问</li></ul></li><li>外部类的静态成员方法中，去访问成员内部类的成员。 <ul><li>无权限现在,new对象后去访问</li></ul></li><li>外部其他类的成员方法中，访问成员内部类的成员。 <ul><li>有外部，和内部的权限 ，通过 new Outer().new Inner() 访问</li></ul></li><li>外部其他类的静态成员方法中，访问成员内部类的成员。 <ul><li>有外部，和内部的权限 ，通过 new Outer().new Inner() 访问</li></ul></li></ol></li><li><p>补全程序，使得可以输出三个num</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="静态内部类" tabindex="-1"><a class="header-anchor" href="#静态内部类" aria-hidden="true">#</a> 静态内部类</h2><p>​ 有时候, 使用内部类只是为了把一个类隐藏在另外一个类的内部, 并不需要内部类有外部类对象的一个引用, 如果使用static来修饰一个成员内部类, 就不会生成那个引用, 则这个内部类就属于外部类本身, 而不是属于外部类的某个对象, 这就是所谓的静态内部类.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//外部类</span>
<span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token class-name">OuterClazz</span><span class="token punctuation">{</span> 
<span class="token comment">// 静态内部类访问权限修饰符，有四个，和普通成员一样</span>
	<span class="token punctuation">[</span>访问权限修饰符<span class="token punctuation">]</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StaticInnerClazz</span><span class="token punctuation">{</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自身特点-1" tabindex="-1"><a class="header-anchor" href="#自身特点-1" aria-hidden="true">#</a> 自身特点</h3><p>依然主要从以下几个角度分析：</p><ol><li>访问权限修饰符</li><li>成员特点</li><li>继承和实现</li></ol><h4 id="访问权限修饰符-1" tabindex="-1"><a class="header-anchor" href="#访问权限修饰符-1" aria-hidden="true">#</a> 访问权限修饰符</h4><p><strong>静态内部类和成员内部类一样，有四种访问权限级别：</strong></p><ol><li>public</li><li>protected</li><li>缺省的，默认访问权限</li><li>private</li></ol><p>注：</p><ol><li>外部类可以保护静态内部类，如果想要访问一个静态内部类。首先需要外部类权限，然后还需要静态内部类权限。</li><li>既然定义内部类，仍然建议私有化。当然具体情况具体分析</li></ol><h4 id="成员特点-1" tabindex="-1"><a class="header-anchor" href="#成员特点-1" aria-hidden="true">#</a> 成员特点</h4><p>要理解静态内部类的成员有什么特点，就要像成员内部类那样，搞清楚，静态内部类到底和外部类是什么关系。<strong>在Oracle公司官网有一段文字解释静态内部类和成员内部类的区别：</strong></p><blockquote><p>Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.</p></blockquote><p>这句话直白的翻译过来就是：</p><blockquote><p>声明为static的嵌套类称为静态嵌套类，非static嵌套类才被成为内部类。</p></blockquote><p>理解这句话，关键点就在于nested和inner的区别：</p><ol><li>nested，嵌套，指的是：直接把一个类丢到另一个类中，两个类其实没太大关系。</li><li>inner，内部，指的是：某个类本身就是另一个类的一部分，在内部。</li></ol><p>这其实就已经说明白了，成员内部类和静态内部类的区别：</p><ol><li><strong><mark>成员内部类必须依赖外部类存在</mark>，创建成员内部类对象必须<mark>持有外部类对象</mark>的引用。</strong></li><li><strong>静态内部类和外部类就是<mark>独立的两个类</mark>，只不过静态内部类借用外部类来保护自己罢了。</strong></li></ol><p>相比较而言，成员内部类和外部类的关系是：心脏——身体，CPU——计算机</p><p>而静态内部类和外部类的关系是：寄居蟹——螺壳，啃老族——他的父母</p><hr><p>搞清楚上面这个问题，其实你已经学会了静态内部类。<span style="color:red;background:yellow;"><strong>它本身就该是一个独立的类，所以它和普通类的成员毫无二致！！！</strong></span></p><h4 id="继承和实现-1" tabindex="-1"><a class="header-anchor" href="#继承和实现-1" aria-hidden="true">#</a> 继承和实现</h4><p>​ 静态内部类的继承与实现和成员内部类并没有太大不同，区别在于，静态内部类只能继承一个静态内部类，而不能继承成员内部类。而且由于静态内部类的独立性很强，在外部，也可以在有权限的情况下，轻松继承一个静态内部类。</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><p>​ 静态内部类很特殊, 因为静态内部类对象和外部类对象完全独立， <span style="color:red;background:yellow;"><strong>静态内部类对象不会持有外部类对象引用</strong></span>，所以它是内部类中的异类。实际开发中，你就将它作为一个可以定义在类的内部，隐藏自身存在的一个普通类，去使用就可以了。</p><h3 id="静态内部类访问特点" tabindex="-1"><a class="header-anchor" href="#静态内部类访问特点" aria-hidden="true">#</a> 静态内部类访问特点</h3><p>在研究具体的访问前，仍先明确以下两点：</p><ol><li>内部类和外部类是&quot;好兄弟&quot;，它们之间的访问不受访问权限限制，包括私有。</li><li>静态内部类对象完全不依赖于部围类对象而存在，这意味着，互相访问，不管在哪都要创建对方对象。</li></ol><h4 id="静态内部类内部访问外部类" tabindex="-1"><a class="header-anchor" href="#静态内部类内部访问外部类" aria-hidden="true">#</a> 静态内部类内部访问外部类</h4><p>​ 不管是静态内部类中的静态方法还是成员方法，都没有外部类对象存在，需要创建对象访问。语法就直接new对象就可以了。创建好对象以后，用对象名访问即可。如果同名，有谁的引用访问的就是谁的。</p><h4 id="外部类访问静态内部类成员" tabindex="-1"><a class="header-anchor" href="#外部类访问静态内部类成员" aria-hidden="true">#</a> 外部类访问静态内部类成员</h4><p>​ 不管是静态内部类中的静态方法还是成员方法，都没有外部类对象存在，需要创建对象访问。语法就直接new对象就可以了。创建好对象以后，用对象名访问即可。如果同名，有谁的引用访问的就是谁的。</p><h4 id="外部其他类访问静态内部类成员" tabindex="-1"><a class="header-anchor" href="#外部其他类访问静态内部类成员" aria-hidden="true">#</a> 外部其他类访问静态内部类成员</h4><p>​ 主要就是考虑权限，先要有外部类权限，再要有静态内部类权限。有权限后就可以创建对象了，但是创建对象时，需要指出外部类是谁（毕竟你住人家房子里），语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">OuterClazz<span class="token punctuation">.</span>StaticInnerClazz</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClazz<span class="token punctuation">.</span>StaticInnerClazz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建对象后，用对象名访问成员即可。<strong>当然这个访问受权限限制。</strong></p><h4 id="静态内部类访问外部其他类成员" tabindex="-1"><a class="header-anchor" href="#静态内部类访问外部其他类成员" aria-hidden="true">#</a> 静态内部类访问外部其他类成员</h4><p>​ 创建对象访问即可，受权限控制</p><h3 id="注意事项-1" tabindex="-1"><a class="header-anchor" href="#注意事项-1" aria-hidden="true">#</a> 注意事项</h3><p>内部类也是类,也需要类加载, 静态内部类和外部类之间的类加载,它们会互相影响吗?</p><p>是不会的, 静态内部类和外补类之间本身没有依赖关系</p><p>它们的类加载,new对象,都是没有关系的</p><h3 id="练习-3" tabindex="-1"><a class="header-anchor" href="#练习-3" aria-hidden="true">#</a> 练习</h3><p>试着说一说下述访问，能否进行，怎么进行，是否受访问权限限制。</p><ol><li>静态内部类的成员方法中，去访问外部类的成员。</li><li>外部类的成员方法中，去访问静态内部类的成员。</li><li>外部类的静态成员方法中，去访问静态内部类的成员。</li><li>外部其他类的成员方法中，访问静态内部类的成员。</li><li>外部其他类的静态成员方法中，访问静态内部类的成员。</li></ol><p>总结一下，成员内部类和静态内部类的用途：</p><p>首要用途是隐藏类，当你在某个位置需要一个对象来完成需求，而你又不希望外界知道这个类时，可以用内部类, 用的时候优先用静态内部类，因为它限制比较少</p><h2 id="局部内部类" tabindex="-1"><a class="header-anchor" href="#局部内部类" aria-hidden="true">#</a> 局部内部类</h2><p>​ 局部内部类是定义在一个方法或者一个作用域里面的类，简单来说，将<mark>局部内部类看成是局部变量</mark>即可，该类的有效范围仅在作用域内部。（这意味着要创建它的对象，必须在作用域内部创建）</p><p>从语法和具体使用上看，局部内部类和成员内部类很相似，有点类似于直接把一个成员内部类放进局部位置，语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 局部位置</span>
<span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span class="token comment">// 局部位置</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自身特点-2" tabindex="-1"><a class="header-anchor" href="#自身特点-2" aria-hidden="true">#</a> 自身特点</h3><h4 id="访问权限修饰符-2" tabindex="-1"><a class="header-anchor" href="#访问权限修饰符-2" aria-hidden="true">#</a> 访问权限修饰符</h4><p>​ 局部内部类和局部变量一样，没有访问修饰权限。因为这毫无意义，大括号已经限制了它的访问范围。同样，局部内部类不能用static关键字修饰，原因和局部变量一样。</p><h4 id="成员特点-2" tabindex="-1"><a class="header-anchor" href="#成员特点-2" aria-hidden="true">#</a> 成员特点</h4><p>局部内部类的成员特点和成员内部类一模一样，不再赘述：</p><ol><li>没有静态static声明，但可以创建全局常量（不触发类加载的）</li><li>有构造方法和构造代码块。</li></ol><h4 id="继承和实现-2" tabindex="-1"><a class="header-anchor" href="#继承和实现-2" aria-hidden="true">#</a> 继承和实现</h4><p>局部内部类可以继承和实现外部的类或者接口，这是局部内部类的一个重要用途。</p><h3 id="局部内部类的访问特点" tabindex="-1"><a class="header-anchor" href="#局部内部类的访问特点" aria-hidden="true">#</a> 局部内部类的访问特点</h3><ol><li>外部类仍然把局部内部类当&quot;好兄弟&quot;，局部内部类访问外部类成员仍不受权限限制。但局部内部类的作用域已被限制死了，外部类中只有装着局部内部类的作用域内，能访问到该局部内部类。</li><li>外部其他类已经完全无法访问到局部内部类了。</li></ol><h4 id="局部内部类在外部类的成员方法中" tabindex="-1"><a class="header-anchor" href="#局部内部类在外部类的成员方法中" aria-hidden="true">#</a> 局部内部类在外部类的成员方法中</h4><p>外部类的成员方法中，是隐含自身类对象的引用的，并且这个引用编译器会自动加入到局部内部类中。也就是说， <strong>处在外部类成员方法中的局部内部类，会持有外部类对象的引用。</strong></p><p>于是：</p><ol><li>可以直接在局部内部类的成员方法中，访问外部类的成员。</li><li>如果出现同名，仍然用外部类类名.this指向外部类对象。</li><li>如果全局常量同名，就用类名点区分。</li></ol><h4 id="局部内部类在外部类的静态成员方法中" tabindex="-1"><a class="header-anchor" href="#局部内部类在外部类的静态成员方法中" aria-hidden="true">#</a> 局部内部类在外部类的静态成员方法中</h4><p>静态方法中就不存在任何对象了，其中的局部内部类也就不会持有引用了。想要访问外部类成员，就需要创建对象了。</p><h3 id="局部内部类的经典使用" tabindex="-1"><a class="header-anchor" href="#局部内部类的经典使用" aria-hidden="true">#</a> 局部内部类的经典使用</h3><p>局部内部类经常使用在以下两个场景中：</p><ol><li><p>方法需要返回一个对象，返回值类型是引用数据类型时。</p><p>方法需要返回一个对象时，可以在方法的局部位置写一个 局部内部类 继承/实现外部的类/接口，创建对象后作为返回值。这是因为方法的返回值可以是返回值类型的对象，也可以是子类对象（当返回值类型是引用数据类型时）。</p></li><li><p>方法需要传入一个对象，形参数据类型是引用数据类型时。</p><p>方法需要传入一个对象实参时，可以在调用方法的位置定义一个 局部内部类 来继承/实现外部的类/接口，创建对象后作为方法的实参传入。这是因为方法的实参可以是形参类型的对象，也可以子类对象（当返回值类型是引用数据类型时）。</p></li></ol><p>使用局部内部类的优点：</p><ol><li>绝对对外界隐藏，封装。</li><li>相比较于传统的定义类，然后创建对象，它相对更加简洁省事。</li></ol><p>缺点：</p><ol><li>这个类是一次性的。</li></ol><p>综上，假如在局部位置需要一次性的使用某个对象，可以使用局部内部类创建它，但是如果多次在不同的方法中使用，使用局部内部类就得不偿失了。</p><h3 id="注意事项-2" tabindex="-1"><a class="header-anchor" href="#注意事项-2" aria-hidden="true">#</a> 注意事项</h3><p>一. 在局部内部类的成员方法中，如果想要访问作用域内部的局部变量，那么该变量：</p><ol><li>要么直接就用final修饰，是一个局部常量。</li><li>要么就是一个事实上的常量，即只能赋值一次，相当于用final修饰它。</li></ol><p>在Java8之前版本的JDK中，如果不给能在局部内部类内部，访问的局部变量直接加上final修饰，会编译报错。</p><p>在最后，特别强调一点。后面学习的 <span style="color:red;background:yellow;"><strong>匿名内部类</strong></span> 和 <span style="color:red;background:yellow;"><strong>Lambda表达式</strong></span> 本质依然是局部内部类，这一条注意事项仍然生效。</p><p>二. 局部内部类对象作为方法的返回值, 返回值类型必须是其父类型</p><h2 id="内部类的优缺点和使用场景" tabindex="-1"><a class="header-anchor" href="#内部类的优缺点和使用场景" aria-hidden="true">#</a> 内部类的优缺点和使用场景</h2>`,90),z=n("strong",null,"场景一：无条件地访问外部类的所有元素（优点）",-1),O=a("<li><strong>场景二：隐藏类</strong><ol><li>可以用private、protected修饰内部类。</li><li>private修饰内部类、外界感受不到该类存在。</li></ol></li><li><strong>场景三：实现多继承</strong><ol><li>可以创建多个成员内部类继承外部多个类</li><li>然后创建内部类对象，实际上就是外部类继承了多个类的成员</li></ol></li><li><strong>场景四：通过匿名内部类来优化简单的接口实现/Lambda表达式更简洁</strong><ul><li><strong>重点：内部类要说使用频率 最高的肯定是匿名内部类和Lambda表达式</strong></li></ul></li>",3),P=n("p",null,"内部类的缺点",-1),J=n("li",null,[n("p",null,"内部类的缺点也是显而易见，语法很复杂，在类中定义内部类也会导致类的结构变复杂，影响代码可读性。")],-1),B=n("p",null,"除此之外，不合理使用内部类还可能导致内存泄漏（了解）",-1),F=n("p",null,"持有外部类对象引用的内部类对象，如果始终被使用而没有释放：",-1),N=n("p",null,"这在极端的场景下，会导致堆内存溢出，存在一定的风险。",-1),U=a(`<h2 id="内部类对象" tabindex="-1"><a class="header-anchor" href="#内部类对象" aria-hidden="true">#</a> 内部类对象</h2><p><strong>学习目标</strong></p><ul><li>熟练掌握匿名内部类使用</li><li>熟练掌握lambda表达式使用</li></ul><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><p>本节内部类<mark>对象</mark>，<strong>本质</strong>上还是属于定义在别的类内部的一个类。</p><p>但区别是： 成员内部类、静态内部类和局部内部类都属于定义了一个类，后续使用还需要基于内部类创建对象。而本节中的匿名内部类和Lambda表达式都是直接通过语法创建了对象。</p><p>最后，在学习匿名内部类和Lambda表达式之前，我们还是要清楚——它们都是<mark>特殊的局部内部类</mark>。所以一旦访问方法的局部变量，该局部变量需要是一个常量(final 修饰)。</p><h3 id="匿名内部类" tabindex="-1"><a class="header-anchor" href="#匿名内部类" aria-hidden="true">#</a> 匿名内部类</h3><p>​ 我们已经使用过匿名对象了，匿名对象的含义是这个对象是没有名字，没有引用指向它。那么匿名内部类，指的就是这个内部类没有名字。当然成员内部类和静态内部类没法没有名字，所以 匿名内部类指的是&quot;没有名字的局部内部类&quot;。是一种特殊</p><h4 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h4><p>在方法等局部位置，写下列语法，即表示定义匿名内部类：</p><div class="language-JAVA line-numbers-mode" data-ext="JAVA"><pre class="language-JAVA"><code>// 局部位置
new 类名或者接口名(){
	// 某类名或接口名的子类的类体
};
// 局部位置
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释说明：</p><ol><li>new表示创建对象，表示创建语法中&quot;类名/接口名&quot;的子类对象。</li><li>这个语法结构，我们只知道这是一个子类对象，但这个子类到底叫啥，不知道，所以它是一个匿名类。当然匿名内部类更准确的说法，应该叫匿名内部类对象。</li><li>匿名内部类的本质是，一个继承了类或者实现了接口的匿名子类对象。</li></ol><h4 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h4><p>匿名内部类是特殊的局部内部类，它的成员特征、访问特征和局部内部类没有区别。这里不再赘述。</p><p>这里我们直接说明一下，匿名内部类对象的两种使用方式：</p><ul><li>可以直接在后面调用方法，访问它的成员（当一个匿名对象使用） <ol><li>优点是：可以访问子类独有的成员。方便快捷，不需要用引用接收再去使用</li><li>缺点是：一次性，仅能用一次</li></ol></li><li>可以用（父）引用接收对象，然后再用引用访问成员 <ol><li>优点是：可以用多次</li><li>缺点是：不能访问子类独有成员（被父类引用限制了访问范围，无法强转，因为子类已经匿名了)</li></ol></li></ul><p>综上，两种使用方式场景不同。如果有多次使用需求，就需要父引用接收；反之如果仅用一次，或者需要访问子类独有成员，就必须直接使用，不能用引用接收。</p><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h4><p>​ 匿名内部类实际上就是更简单的局部内部类（直接获取了对象），所以局部内部类的使用场景，可以直接套用过来。</p><p>匿名内部类经常使用在以下两个场景中：</p><ol><li><p>方法需要返回一个对象，返回值类型是引用数据类型时。</p><p>方法需要返回一个对象时，可以在方法的局部位置写一个 基于X类或X接口的匿名内部类对象 ，然后直接作为返回值返回给外界。</p></li><li><p>方法需要传入一个对象，形参数据类型是引用数据类型时。</p><p>方法需要传入一个对象实参时，可以在调用方法的实参位置填入一个 基于X类或X接口的匿名内部类对象，就将它作为一个实参传给方法使用。</p></li></ol><p>使用匿名内部类的优点：</p><ol><li>绝对对外界隐藏，封装。</li><li>比起局部内部类，它更方便简洁了。所以实际开发中，匿名内部类基本取代了局部内部类的作用。</li></ol><p>缺点：</p><ol><li>这个对象是一次性的。</li></ol><p>总之，酌情使用匿名内部类对象，可以简化代码书写，方便省事。但不要为了使用而使用，假如存在多个场景都需要一个子类对象，那还是直接创建一个子类出来好了。</p><h4 id="练习-4" tabindex="-1"><a class="header-anchor" href="#练习-4" aria-hidden="true">#</a> 练习</h4><p>不修改main方法和接口Inter的前提下，补齐Outer类代码，要求在控制台输出HelloWorld</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name">Outer</span><span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Inter</span> <span class="token punctuation">{</span>
 <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>几种实现方式:</p><ul><li>手写类实现接口</li><li>局部内部类</li><li>匿名内部类</li><li>lambda表达式</li></ul><h3 id="lambda表达式" tabindex="-1"><a class="header-anchor" href="#lambda表达式" aria-hidden="true">#</a> lambda表达式</h3><p>Lambda 表达式是 JDK8 的一个新特性，可以取代接口的匿名内部类，写出更优雅的Java 代码。</p><ol><li>Lambda表达式仍然是局部内部类，是特殊的局部内部类，仍然定义在局部位置。而且局部内部类的注意事项，也一样存在。</li><li>Lambda表达式在取代匿名内部类时，不是全部都取代，而是取代<strong>接口</strong>的匿名内部类，而类的匿名内部类Lambda表达式是不能取代的。</li><li>Lambda表达式是匿名内部类的更进一步， Lambda表达式得到的也不是一个类，而是一个对象，并且是接口的子类对象。</li></ol><h4 id="使用前提" tabindex="-1"><a class="header-anchor" href="#使用前提" aria-hidden="true">#</a> 使用前提</h4><p>Lambda表达式虽然说是取代<mark>接口的匿名内部类</mark>，但也不是什么接口都能用Lambda表达式创建子类对象。</p><p>Lambda表达式要求的接口中，必须<mark>有且仅有一个必须要实现的抽象方法</mark>。这种接口在Java中，被称之为&quot;功能接口&quot;。功能接口在语法上，可以使用注解==@FunctionalInterface<mark>标记在接口头上，用于</mark>检测一个接口是否是功能接口==。</p><p>例如：</p><p>注解@FunctionalInterface</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IA</span><span class="token punctuation">{</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中<code>IA</code>接口就是一个功能接口，注解就不会编译报错，反之就会编译报错。这有点类似于@Override注解对方法重写的检验。</p><hr><p>看完上述关于功能接口的语法定义，思考两个问题：</p><ol><li>功能接口中只能有一个方法吗？</li><li>功能接口中只能有一个抽象方法吗？</li></ol><p>答：</p><ol><li><p>不是，Java8中的默认方法和静态方法不需要子类实现，功能接口中可以允许有它们存在。</p></li><li><p>不是，有极个别比较特殊的抽象方法，可以不需要子类实现。</p><p>注：Object类是Java每一个类的父类，所以Object类当中的方法实现就可以作为接口抽象方法的实现。比如：</p><p>功能接口不仅有一个抽象方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IA</span><span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>接口IA仍然是一个功能方法，因为抽象方法boolean equals(Object obj);可以直接使用Object类中的实现，无需子类实现。</p><p>所以，再强调一下，<strong>功能接口指的是，有且仅有一个必须要子类实现的抽象方法的接口。</strong></p><h4 id="基本使用-1" tabindex="-1"><a class="header-anchor" href="#基本使用-1" aria-hidden="true">#</a> 基本使用</h4><p>​ 功能接口准备完毕后，就可以写Lambda表达式的语法，表示创建功能接口的子类对象了。当然Lambda表达式是特殊的局部内部类，仍然要写在局部位置。</p><p>它的语法是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
<span class="token comment">// 方法体	</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释一下：</p><ol><li>(形参列表)表示功能接口中，必须要重写的抽象方法的形参列表。</li><li>-&gt;由一个英文横杠 + 英文大于号字符组成，它是Lambda表达式的运算符，读作<mark>goes to</mark>。</li><li>{ //方法体 }表示功能接口中，必须要重写的抽象方法的，方法体实现。</li></ol><p>其实，看完这个Lambda表达式的语法定义，就已经能够解释为什么Lambda表达式，要求接口有且只有一个必须要实现的抽象方法了。因为语法中仅有一套形参列表和方法体，只能重写一个方法。</p><p>而且，这个语法写出来，很明显Lambda表达式只能重写父接口中的抽象方法，是不能自己新增成员的！</p><hr><p>在方法等局部位置，写上述语法后，肯定会报错。原因在于Java是强类型语言，任何变量都有它的数据类型，而直接写Lambda表达式语言，编译器是无从得知它的数据类型的——这个Lambda表达式创建了接口的子类对象，到底是哪个接口的子类对象呢？</p><p>所以我们需要帮助编译器，明确Lambda表达式所表示的对象的类型，这个过程称之为 &quot;Lambda表达式的类型推断&quot;。</p><p>怎么推断呢？在这个推断过程中，需要给编译器提供额外的信息，告诉它Lambda表达式是哪个接口的子类对象。总得来说，常见和常用的有以下三种方式：</p><ol><li><p>直接用父接口引用接收。由于Lambda表达式表示的子类对象并没有自己独有的成员，所以直接用父类引用接收完全不会有任何问题。</p></li><li><p>不用引用接收，但是要直接告诉编译器Lambda表达式是哪个接口的子类对象，语法上有点像强转（但不是）。</p><p>语法：</p><p>((父接口的名字)Lambda表达式).方法名(实参)</p><p>这种方式有点类似于匿名对象，所以必须直接调用方法，不然会编译语法报错。</p></li><li><p>借助方法完成类型推断。</p><ol><li>可以借助方法的返回值数据类型完成类型推断，因为方法的返回值编译器已经知道该返回什么对象。</li><li>可以借助方法的形参的数据类型完成类型推断，因为方法的实参编译器已经知道该传入什么对象。</li></ol></li></ol><h4 id="进阶使用和简化" tabindex="-1"><a class="header-anchor" href="#进阶使用和简化" aria-hidden="true">#</a> 进阶使用和简化</h4><p>为了方便语法练习，这里给出六个功能接口：</p><p>功能接口案例</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//无返回值无参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">INoReturnNoParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//无返回值有一个参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">INoReturnOneParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//无返回值两个参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">INoReturnTwoParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//有返回值无参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IHasReturnNoParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//有返回值一个参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IHasReturnOneParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//有返回值两个参数的功能接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IHasReturnTwoParam</span> <span class="token punctuation">{</span>
 <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们基于上述功能接口，讲解一下Lambda表达式的进阶使用， 主要就是格式的简化</p><p>逐个部分简化：</p><ol><li><p>(形参列表)能不能简化呢？是可以的，因为功能接口中有且仅有一个必须要实现的抽象方法，那么：</p><ol><li><mark>形参的数据类型是可以省略的</mark>，因为方法已经固定死了，形参一定是那些，不需要写出来。但形参的名字是不可省略的（因为要在方法体中使用）</li><li>特殊情况下： <ul><li>如果形参列表中的形参只有一个，那么()小括号，也是可以省略的。</li><li>但是如果形参为空，()小括号是不可以省略的。</li></ul></li></ol></li><li><p>{ //方法体 }方法体能不能简化呢？当然是可以的：</p><ol><li>如果方法重写的方法体只有一条语句的话，那么可以省略大括号。（类似于if/for省略大括号）</li><li>特殊的，如果只有一条语句且这条语句是返回值语句，那么大括号和return可以一起省略。</li></ol></li><li><p>实际上在多数情况下，都不太可能一句话把方法体写完。多数情况下，Lambda表达式的抽象方法实现都会很复杂，那这样Lambda表达式就会写的很复杂，这就很难受了。而Lambda表达式，本质上就是重写了一个抽象方法的子类对象，所以Java允许Lambda表达式的抽象方法的实现可以直接指向一个已经存在的方法，而不是自己书写实现。这种语法在Java中称之为&quot;方法引用&quot;！</p><h4 id="方法引用" tabindex="-1"><a class="header-anchor" href="#方法引用" aria-hidden="true">#</a> 方法引用</h4><p>Lambda表达式的主体只有1条语句时, 程序不仅可以省略主体的大括号, 还可以通过==英文双冒号::==的语法来引用方法, 进一步简化Lambda表达式的书写.</p><p>什么样的方法，能够作为<mark>方法引用</mark>指向的功能接口中抽象方法的实现？只看三点：</p><ol><li><mark>返回值类型必须一致。</mark></li><li>(方法签名method signature一致)形参列表中的<mark>数量，类型，位置</mark>必须都对应上，形参名字无所谓。</li><li>方法的名字无所谓。</li></ol><p><strong>Lambda表达式支持的方法引用</strong></p><table><thead><tr><th>种类</th><th>Lambda表达式示例</th><th>对应的引用示例</th><th>解释说明</th></tr></thead><tbody><tr><td>类名引用静态方法</td><td>(x, y, ...) -&gt; 类名.静态方法名(x, y, ...)</td><td>类名::静态方法名</td><td>功能接口中被实现方法的全部参数传给该类静态方法作为参数</td></tr><tr><td>对象名引用成员方法</td><td>(x, y, ...) -&gt; 对象名.成员方法名(x, y, ...)</td><td>对象名::成员方法名</td><td>功能接口中被实现方法的全部参数传给该成员方法作为参数</td></tr><tr><td><mark>类名引用成员方法(<strong>特殊</strong>)</mark></td><td><mark>(x, y, ...) -&gt; **对象名x.**成员方法名(y, ...)</mark></td><td>类名::成员方法名(<strong>不是静态方法</strong>)</td><td><mark>功能接口中被实现方法的第一个参数作为调用者, 后面的参数传给该成员方法作为参数</mark></td></tr><tr><td>构造方法引用</td><td>(x, y, ...) -&gt; new 类名(x, y, ...)</td><td>类名::new</td><td>功能接口中被实现方法的全部参数传给该构造器作为参数</td></tr></tbody></table></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">/*
Lambda表达式的主体只有1条语句时, 程序不仅可以省略主体的大括号,
还可以通过英文双冒号::的语法来引用方法, 进一步简化Lambda表达式的书写.

什么样的方法，能够作为方法引用指向的功能接口中抽象方法的实现？
只看三点：
1. 返回值类型必须一致。
2. (方法签名method signature一致)形参列表中的数量，类型，位置必须都对应上，
形参名字无所谓。
3. 方法的名字无所谓。
 */</span>
<span class="token comment">/*
1.静态方法引用
2.对象名引用成员方法
3.类名引用成员方法
4.构造方法引用
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 静态方法引用</span>
        <span class="token comment">// lambda写法</span>
        <span class="token class-name">IA</span> ia2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ia2<span class="token punctuation">.</span><span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">IA</span> ia <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ia<span class="token punctuation">.</span><span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 方法引用</span>
        <span class="token class-name">IA</span> ia1 <span class="token operator">=</span> <span class="token class-name">A</span><span class="token operator">::</span><span class="token function">func1</span><span class="token punctuation">;</span>
        ia1<span class="token punctuation">.</span><span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token comment">// 对象名引用成员方法</span>
        <span class="token comment">// lambda</span>
        <span class="token class-name">IC</span> ic2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        ic2<span class="token punctuation">.</span><span class="token function">testC</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">IC</span> ic <span class="token operator">=</span>  a <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ic<span class="token punctuation">.</span><span class="token function">testC</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 方法引用</span>
        <span class="token class-name">IC</span> ic1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">::</span><span class="token function">func2</span><span class="token punctuation">;</span>
        ic1<span class="token punctuation">.</span><span class="token function">testC</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token comment">//IB ib = s -&gt; System.out.println(s);</span>
        <span class="token comment">//ib.testB(&quot;aaa&quot;);</span>

        <span class="token comment">// 可以指向源码中的方法或者第三方工具的方法</span>
        <span class="token class-name">IB</span> ib <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">;</span>
        ib<span class="token punctuation">.</span><span class="token function">testB</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>



        <span class="token comment">// &quot;abcdef&quot;, 希望对字符串进行截取&quot;bc&quot;</span>
        <span class="token comment">// 主要使用String类中的成员方法</span>
        <span class="token comment">// subString( int start,int end)  [start,end)</span>
        <span class="token comment">//String s = &quot;abcdef&quot;;</span>
        <span class="token comment">//String substring = s.substring(1, 3);</span>
        <span class="token comment">//System.out.println(&quot;substring = &quot; + substring);</span>


        <span class="token comment">// 类名引用成员方法</span>
        <span class="token comment">// lambda</span>
        <span class="token class-name">ID</span> id <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> str <span class="token operator">=</span> id<span class="token punctuation">.</span><span class="token function">testD</span><span class="token punctuation">(</span><span class="token string">&quot;abcdef&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;str = &quot;</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token class-name">ID</span> id2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">substring</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> str2 <span class="token operator">=</span> id2<span class="token punctuation">.</span><span class="token function">testD</span><span class="token punctuation">(</span><span class="token string">&quot;abcdef&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;str2 = &quot;</span> <span class="token operator">+</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token comment">// 4.构造方法引用</span>
        <span class="token comment">// lambda表达式</span>
        <span class="token comment">// 有参构造</span>
        <span class="token class-name">IE</span> ie <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Dog</span> dog <span class="token operator">=</span> ie<span class="token punctuation">.</span><span class="token function">getDog</span><span class="token punctuation">(</span><span class="token string">&quot;小黑&quot;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 无参构造</span>
        <span class="token class-name">IG</span> ig <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Dog</span> dog1 <span class="token operator">=</span> ig<span class="token punctuation">.</span><span class="token function">getDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 方法引用</span>
        <span class="token class-name">IE</span> ie2 <span class="token operator">=</span> <span class="token class-name">Dog</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span>
        <span class="token class-name">Dog</span> dog2 <span class="token operator">=</span> ie2<span class="token punctuation">.</span><span class="token function">getDog</span><span class="token punctuation">(</span><span class="token string">&quot;小花&quot;</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog2<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">IG</span> ig2 <span class="token operator">=</span> <span class="token class-name">Dog</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span>
        <span class="token class-name">Dog</span> dog3 <span class="token operator">=</span> ig2<span class="token punctuation">.</span><span class="token function">getDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog3<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IA</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">testA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token comment">// 定义一个静态方法 作为IA接口中的testA方法的实现</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;IA接口中的testA方法的实现&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IB</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">testB</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IC</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">testC</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">ID</span><span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">testD</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IE</span><span class="token punctuation">{</span>
    <span class="token class-name">Dog</span> <span class="token function">getDog</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">IG</span><span class="token punctuation">{</span>
    <span class="token class-name">Dog</span> <span class="token function">getDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">{</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="注意事项-3" tabindex="-1"><a class="header-anchor" href="#注意事项-3" aria-hidden="true">#</a> 注意事项</h4><ol><li>方法引用所指向的实现方法, 只要是已经存在的就可以, 可以自己写, 可以用源码的方法或者第三方工具类的方法</li><li>Lambda表达式是特殊的局部内部类，所以它访问方法的局部变量，该变量必须是final的（实际常量）。</li><li>除此之外，局部内部类，匿名内部类它们都有自己独立的作用域，能够自定义自己的成员。 <span style="color:red;background:yellow;"><strong>但是Lambda表达式没有自身独立的作用域，不能自定义成员，和所在的方法共用同一个作用域。</strong></span></li></ol><h4 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h4><ol><li><p>优点：</p><ol><li><p><strong>极大得简化了代码，使代码变得更加优雅。</strong></p></li><li><p>函数式编程的代表，可能是未来高端的编程趋势</p><ul><li>Lambda表达式在Stream API中，配合集合类去使用，代码非常优雅和简洁，并且高效，实际开发中十分常用。</li></ul><p>Stream API代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>list<span class="token punctuation">.</span>
  <span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
	<span class="token function">filter</span><span class="token punctuation">(</span>stu <span class="token operator">-&gt;</span> stu<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
	<span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getScore</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
	<span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：该Stream API完成，将学生对象集合中的，所有大于等于18岁的学生的成绩输出的工作。</p></li></ol></li><li><p>缺点：</p><ol><li>过于简单的Lambda表达式，显然可读性很低。</li><li>过于简洁也意味着不容易Debug。</li><li>语法难度不低，熟练使用需要时间锻炼。</li></ol></li></ol>`,75);function T(V,X){const t=i("font");return o(),c("div",null,[r,n("ul",null,[k,v,n("li",null,[m,n("ol",null,[b,h,n("li",null,[n("p",null,[s("抽象方法。首先抽象类可以没有抽象方法，但是如果一个抽象类没有抽象方法，那么它就没有必要声明为抽象，直接声明为普通类就够了。"),e(t,{color:"red"},{default:p(()=>[g]),_:1}),s("抽象方法最重要的作用是起到 "),y,s(" 的作用，任何普通类继承了该抽象类，都必须实现该抽象方法（强制的）")]),f])])]),w,x]),q,n("ol",j,[n("li",null,[s("抽象类的作用是：做为继承体系中的顶层父类、祖先类而存在的。说白了所有继承了该抽象类的对象，都应该是一个该抽象类的对象。比如我定义了一个抽象的Person类，那么Student、Teacher等继承它是没问题的，但是让一个Cat继承就不行了（即便有成员可以复用）。"),e(t,{color:"red"},{default:p(()=>[S]),_:1})])]),_,e(t,{color:"red"},{default:p(()=>[s("**首先，访问不受权限限制，即便是私有private，也阻止不了访问。**")]),_:1}),I,e(t,{color:"red"},{default:p(()=>[s("**首先，访问不受权限限制，即便是私有private，也阻止不了访问。**")]),_:1}),C,n("ol",null,[L,D,n("li",null,[e(t,{color:"red"},{default:p(()=>[s("**受访问权限控制。**")]),_:1})])]),A,n("ul",null,[n("li",null,[z,n("ul",null,[n("li",null,[e(t,{color:"red"},{default:p(()=>[s("**无论是成员内部类、静态内部类、局部内部类还是匿名内部类都可以无条件访问包裹着它的外部类的成员。**")]),_:1})])])]),O]),P,n("ol",null,[J,n("li",null,[B,n("blockquote",null,[F,e(t,{color:"red"},{default:p(()=>[s("**那么连带着外部类对象，也不会被销毁和释放内存。**")]),_:1}),N])])]),U])}const G=l(d,[["render",T],["__file","6_面向对象设计.html.vue"]]);export{G as default};
